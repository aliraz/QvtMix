import qvt.mix.util;



modeltype QVT uses qvtoperational::expressions('http://www.eclipse.org/QVT/1.0.0/Operational');
modeltype ImpOCL uses ImperativeOCL('http://www.eclipse.org/qvt/1.0/ImperativeOCL');


modeltype OCL uses ocl::utilities('http://www.eclipse.org/ocl/1.1.0/OCL');
modeltype OCLECORE uses ocl::ecore('http://www.eclipse.org/ocl/1.1.0/OCL');

modeltype OCLTYPE uses ocl::types('http://www.eclipse.org/ocl/1.1.0/OCL');
modeltype ECORE uses ecore('http://www.eclipse.org/emf/2002/Ecore');
modeltype BTA uses 'http://qvt.bta/1.0';
modeltype BOOK uses 'http://book/1.0';





transformation QvtMix(
	in inputMetaModel : ECORE,
	in inputModel : ECORE, 
	in qvt : QVT,
	in outputModel : ECORE,
	in outputMetaModel : ECORE,
	out residue : QVT
);



///////////////////////////////////////////////////////////////////////////////
//
// main
//
///////////////////////////////////////////////////////////////////////////////


main() {	
	var trans := qvt.rootObjects()[OperationalTransformation]->asOrderedSet()->first();
	trans.bta(bindingTimes, context);



	var resQvt := trans.mix();
	log('import qvt.mix.util;');
	log('modeltype ECORE uses ecore(\'http://www.eclipse.org/emf/2002/Ecore\');');
	
	log(resQvt.print(0));
	
	log('
///////////////////////// ModelUtils ///////////////////////////////////////////////////
intermediate class ObjectPath {
	path : String;
}

helper EObject::path() : String {
	var parents : OrderedSet(Integer) := OrderedSet{};
	var containers : OrderedSet(Integer) := OrderedSet{};
	var path := \'\';
	var obj := self;
	var parentObj := obj.eContainer();
	while (parentObj <> null) {
		var container := obj.eContainingFeature().oclAsType(EReference);
		var col := Sequence{};
		getMultiFeature(parentObj, container.name, col);
		var position := col->indexOf(obj);
		path := \'/\' + container.name + \'.\' + position.repr() + path;
		obj := parentObj;
		parentObj := obj.eContainer();
	};
	if path = \'\' then {
		path := \'/\';
	}
	endif;
	return path;
}

helper Model::getObject(p : ObjectPath) : EObject {
	var str := p.path;
	var obj := self.rootObjects()->asOrderedSet()->first().oclAsType(EObject);
	str := str.substringAfter(\'/\');
	while (str <> null) {
		var segment := str.substringBefore(\'/\');
		var pos : String; 
		var cont : String;
		if segment <> null then {
			pos := segment.substringAfter(\'.\');
			cont := segment.substringBefore(\'.\');
		}
		else {
			pos := str.substringAfter(\'.\');
			cont := str.substringBefore(\'.\');				
		}
		endif;
		obj := obj.getObject(cont, pos.asInteger());
		str := str.substringAfter(\'/\');
	};	
	
	return obj;
}

helper ObjectPath::getObject(model : Model) : EObject {
	return model.getObject(self);
}

helper EObject::getObject(cont : String, pos : Integer) : EObject {
	var col := Sequence{};
	getMultiFeature(self, cont, col);	
	return col->at(pos).oclAsType(EObject);
}
	');
}

///////////////////////// ModelUtils ///////////////////////////////////////////////////

intermediate class ObjectPath {
	path : String;		
	rootObject : EObject;
};

constructor ObjectPath::ObjectPath(root : EObject, p : String) {
	path := p;
	rootObject := root;	
}


///////////////////////////////////////////////////////////////////////////////
//
// ObjectPath::getObject
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectPath::getObject(model : Model) : EObject {
	return model.getObject(self);
}


///////////////////////////////////////////////////////////////////////////////
//
// EObject::path
//
///////////////////////////////////////////////////////////////////////////////

helper EObject::path() : ObjectPath {
	var parents : OrderedSet(Integer) := OrderedSet{};
	var containers : OrderedSet(Integer) := OrderedSet{};
	var path := '';
	var obj := self;
	var parentObj := obj.eContainer();
	while (parentObj <> null) {
		var container := obj.eContainingFeature().oclAsType(EReference);
		var col := Sequence{};
		getMultiFeature(parentObj, container.name, col);
		var position := col->indexOf(obj);
		path := '/' + container.name + '.' + position.print() + path;
		obj := parentObj;
		parentObj := obj.eContainer();
	};
	if path = '' then {
		path := '/';
	}
	endif;
	return new ObjectPath(obj, path);
}


///////////////////////////////////////////////////////////////////////////////
//
// Model::getObject
//
///////////////////////////////////////////////////////////////////////////////

helper Model::getObject(path : ObjectPath) : EObject {
	var str := path.path;
	var obj := self.rootObjects()->asOrderedSet()->first().oclAsType(EObject);
	str := str.substringAfter('/');
	while (str <> null) {
		var segment := str.substringBefore('/');
		var pos : String; 
		var cont : String;
		if segment <> null then {
			pos := segment.substringAfter('.');
			cont := segment.substringBefore('.');
		}
		else {
			pos := str.substringAfter('.');
			cont := str.substringBefore('.');				
		}
		endif;
		obj := obj.getObject(cont, pos.asInteger());
		str := str.substringAfter('/');
	};	
	
	return obj;
}


///////////////////////////////////////////////////////////////////////////////
//
// ObjectPath::makeExp
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectPath::makeExp() : OCLExpression {
	return self.path.makeExp();
}


///////////////////////////////////////////////////////////////////////////////
//
// EObject::getObject
//
///////////////////////////////////////////////////////////////////////////////

helper EObject::getObject(cont : String, pos : Integer) : EObject {
	var col := Sequence{};
	getMultiFeature(self, cont, col);	
	return col->at(pos).oclAsType(EObject);
}


///////////////////////////////////////////////////////////////////////////////
//
// memoizeVariable
//
///////////////////////////////////////////////////////////////////////////////

helper memoizeVariable(variable : String, path : ObjectPath, val : OclAny) {
	var newpart := object DictLiteralPart {
			key := path.makeExp();
			value := val.makeExp();
	};
	var prop : EAttribute;
	if memoizeTables->hasKey(variable) then {
		prop := memoizeTables->get(variable);
		var dict := prop.eAnnotations.contents->first().oclAsType(DictLiteralExp);
		var parts := dict.part->asOrderedSet();
		parts += newpart;
		dict.part := parts->asSet();
		var annot := object EAnnotation {
			contents := OrderedSet{dict.oclAsType(EObject)};
		};
		setMultiFeature(prop, 'eAnnotations', Sequence{annot});
	}
	else {
		var dict := object DictLiteralExp {
			part := Set{newpart};	
		};
		prop := object EAttribute {
			name := variable;
			eType := object DictionaryType {
				keyType := object PrimitiveType {
					name := 'String';
				};
				elementType := newpart.value.eType.oclAsType(EObject);
				name := 'Dict(String, ' +  newpart.value.typeName() + ')';
			};
			eAnnotations := OrderedSet{
				object EAnnotation {
					contents := OrderedSet{dict.oclAsType(EObject)};
				}
			};
		};
	}
	endif;
	memoizeTables->put(variable, prop);
}


///////////////////////////////////////////////////////////////////////////////
//
// getCacheType
//
///////////////////////////////////////////////////////////////////////////////

helper getCacheType(cache : String) : String {
	if memoizeTables->hasKey(cache)	then {
		var table := memoizeTables->get(cache);
		return table.eType.oclAsType(DictionaryType).name;	
	}
	endif;
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// EObject::getElementType
//
///////////////////////////////////////////////////////////////////////////////

helper EObject::getElementType() : EObject {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// EClassifier::getElementType
//
///////////////////////////////////////////////////////////////////////////////

helper EClassifier::getElementType() : EObject {
	return self.oclAsType(EObject);
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionType::getElementType
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionType::getElementType() : EObject {
	return self.elementType;
}


///////////////////////////////////////////////////////////////////////////////
//
// DictionaryType::getElementType
//
///////////////////////////////////////////////////////////////////////////////

helper DictionaryType::getElementType() : EObject {
	return self.elementType;
}



///////////////////////////////////////////////////////////////////////////////
//
// OclAny::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper OclAny::typeName() : String {
	if self.oclIsKindOf(EObject) then {
		return self.oclAsType(EObject).typeName();
	}
	endif;
	return 'OclAny';
}


///////////////////////////////////////////////////////////////////////////////
//
// Integer::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper Integer::typeName() : String {
	return 'Integer';
}


///////////////////////////////////////////////////////////////////////////////
//
// IntegerLiteralExp::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper IntegerLiteralExp::typeName() : String {
	return 'Integer';
}



///////////////////////////////////////////////////////////////////////////////
//
// RealLiterealExp::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper RealLiteralExp::typeName() : String {
	return 'Real';
}


///////////////////////////////////////////////////////////////////////////////
//
// String::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper String::typeName() : String {
	return 'String';
}


///////////////////////////////////////////////////////////////////////////////
//
// StringLiteralExp::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper StringLiteralExp::typeName() : String {
	return 'String';
}


///////////////////////////////////////////////////////////////////////////////
//
// EObject::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper EObject::typeName() : String {
	return self.eClass().name;
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::typeName() : String {
	var type : String := self.type;
	if not self.collection()->isEmpty() then {
		type := type +  '(' + self.collection()->selectOne(true).typeName() + ')';
	}
	endif;
	return type;
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionLiteralExp::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionLiteralExp::typeName() : String {
	var type : String := self.eType.name.substringBefore('(');	
	type := type + '('	+ self.part->first().typeName() + ')';
	return type;
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionItem::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionItem::typeName() : String {
	return self.item.typeName();
}


///////////////////////////////////////////////////////////////////////////////
//
// ObjectExp::typeName
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectExp::typeName() : String {
	return self.instantiatedClass.name;	
}

//////////////////////// ExpSimplify //////////////////////////////////////////////////

intermediate class ArithmaticExp extends OCLExpression {
	left : OCLExpression;
	right : OCLExpression;
	op : String;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::toArithmaticExp
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::toArithmaticExp() : OCLExpression {
	return self;
}


///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::toArithmaticExp
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::OperationCallExp::toArithmaticExp() : OCLExpression {
	var oper := self.referredOperation.oclAsType(EOperation);
	var lexp := self.source.oclAsType(OCLExpression);
	var rexp := self.argument->first().oclAsType(OCLExpression);
	var res := object ArithmaticExp {
		left := lexp.toArithmaticExp();
		right := rexp.toArithmaticExp();
	};
	switch {
		case (oper.name = '+')
		{
			res.op := 'ADD';
		}
		case (oper.name = '-')
		{
			res.op := 'SUB';
		}
		case (oper.name = '*')
		{
			res.op := 'MUL';
		}
		case (oper.name = '/')
		{
			res.op := 'DIV';
		}
		else 
		{
			return self;
		}
		
	};
	
	return res;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::toOperationCall
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::expressions::OCLExpression::toOperationCall() : ocl::expressions::OCLExpression {
	return self;
}


///////////////////////////////////////////////////////////////////////////////
//
// ArithmaticExp::toOperationCall
//
///////////////////////////////////////////////////////////////////////////////

helper ArithmaticExp::toOperationCall() : ocl::expressions::OCLExpression {
	var lexp := self.left.toOperationCall();
	var rexp := self.right.toOperationCall();
	var res := object OperationCallExp {
		source := lexp;
	};
	res.argument += rexp;
	var opName : String;
	switch {
		case (self.op = 'ADD') {opName := '+'}
		case (self.op = 'SUB') {opName := '-'}
		case (self.op = 'MUL') {opName := '*'}
		case (self.op = 'DIV') {opName := '/'}
	};
	res.referredOperation := object EOperation {
		name := opName;
	}.oclAsType(EObject);
	return res;
}



///////////////////////////////////////////////////////////////////////////////
//
// makeVariableExp
//
///////////////////////////////////////////////////////////////////////////////

helper makeVariableExp(s : String) : VariableExp {
	return object VariableExp {
		referredVariable := object Variable {
			name := s;
		};
		name := referredVariable.oclAsType(Variable).name;
	};
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::simplify
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::simplify() : OCLExpression {
	return self;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::isSame
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::isSame(r : OCLExpression) : Boolean {
	return self = r;
}


///////////////////////////////////////////////////////////////////////////////
//
// VaraibleExp::isSame
//
///////////////////////////////////////////////////////////////////////////////

helper VariableExp::isSame(r : OCLExpression) : Boolean {
	return r.oclIsKindOf(VariableExp) and 
		self.referredVariable.oclAsType(Variable).name = r.oclAsType(VariableExp).referredVariable.oclAsType(Variable).name
	;
}


///////////////////////////////////////////////////////////////////////////////
//
// IntegerLiteralExp::isSame
//
///////////////////////////////////////////////////////////////////////////////

helper IntegerLiteralExp::isSame(r : OCLExpression) : Boolean {
	return r.oclIsKindOf(IntegerLiteralExp) and 
		(self.integerSymbol = r.oclAsType(IntegerLiteralExp).integerSymbol)
	;
}


///////////////////////////////////////////////////////////////////////////////
//
// ArithmaticExp::isSame
//
///////////////////////////////////////////////////////////////////////////////

helper ArithmaticExp::isSame(r : OCLExpression) : Boolean {
	if r.oclIsKindOf(ArithmaticExp) then {
		var rexp := r.oclAsType(ArithmaticExp);
		switch {
			case (self.op <> rexp.op)
			{
				return false;
			}
			case (self.op = 'MUL' or self.op = 'ADD')
			{
				return
					(
						(self.left.isSame(rexp.left)) and (self.right.isSame(rexp.right))
					) or
					(
						(self.left.isSame(rexp.right)) and (self.right.isSame(rexp.left))
					) 
				;	
			}
			else 
			{
				return (self.left.isSame(rexp.left)) and (self.right.isSame(rexp.right));
			}
		};
	}
	endif;
	return false;
}


///////////////////////////////////////////////////////////////////////////////
//
// ArithmaticExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ArithmaticExp::print(tabs : Integer) : String {
	var code := '';
	switch {
		case (self.op = 'ADD') 
		{
			return '(' + self.left.print(0) + ' + ' + self.right.print(0) + ')';
		}
		case (self.op = 'SUB')
		{
			return '(' + self.left.print(0) + ' - ' + self.right.print(0) + ')';
		}
		case (self.op = 'MUL')
		{
			return '(' + self.left.print(0) + ' * ' + self.right.print(0) + ')';
		}
		case (self.op = 'DIV')
		{
			return '(' + self.left.print(0) + ' / ' + self.right.print(0) + ')';
		}
		case (self.op = 'NEG')
		{
			return '-' + self.left.print(0);
		}
	};
	
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ArithmaticExp::simplify
//
///////////////////////////////////////////////////////////////////////////////

helper ArithmaticExp::simplify() : OCLExpression {
	var lexp := self.left.simplify();
	var rexp := self.right.simplify();
	switch {
		case (self.op = 'ADD')
		{
			switch {
				case (lexp.oclIsKindOf(IntegerLiteralExp) and rexp.oclIsKindOf(IntegerLiteralExp))
				{
					return object IntegerLiteralExp {
						integerSymbol := 
							lexp.oclAsType(IntegerLiteralExp).integerSymbol +
							rexp.oclAsType(IntegerLiteralExp).integerSymbol
						;
					};
				}
				case (rexp.oclIsKindOf(IntegerLiteralExp) and 
						rexp.oclAsType(IntegerLiteralExp).integerSymbol = 0)
				{
					return lexp;
				}
				case (lexp.oclIsKindOf(IntegerLiteralExp) and 
						lexp.oclAsType(IntegerLiteralExp).integerSymbol = 0)
				{
					return rexp;
				}
				case (lexp.oclIsKindOf(IntegerLiteralExp))
				{
					return object ArithmaticExp {
						left := rexp;
						right := lexp;
						op := 'ADD';
					};
				}
				case (rexp.oclIsKindOf(IntegerLiteralExp) and 
					rexp.oclAsType(IntegerLiteralExp).integerSymbol < 0)
				{
					var rval := rexp.oclAsType(IntegerLiteralExp).integerSymbol;
					return object ArithmaticExp {
						left := lexp;
						right := (-rval).makeExp();
						op := 'SUB';
					}.simplify();
				}
				case (lexp.oclIsKindOf(ArithmaticExp) and 
						lexp.oclAsType(ArithmaticExp).op = 'ADD')
				{
					return object ArithmaticExp {
						left := lexp.oclAsType(ArithmaticExp).left.simplify();
						right := object ArithmaticExp {
							left := lexp.oclAsType(ArithmaticExp).right;
							right := rexp;
							op := 'ADD';
						}.simplify();
						op := 'ADD';
					}.simplify();
				}
				case (lexp.oclIsKindOf(ArithmaticExp) and 
					   lexp.oclAsType(ArithmaticExp).op = 'SUB')
				{
					return object ArithmaticExp {
						left := lexp.oclAsType(ArithmaticExp).left.simplify();
						right := object ArithmaticExp {
							left := object ArithmaticExp {
								left := lexp.oclAsType(ArithmaticExp).right;
								op := 'NEG';	
							}.simplify();
							right := rexp;
							op := 'ADD';
						};
						op := 'ADD';
					}.simplify();
				}
				case (lexp.oclIsKindOf(VariableExp) and 
						rexp.oclIsKindOf(ArithmaticExp)) // x + (y + x)
				{
					var r := rexp.oclAsType(ArithmaticExp);
					if (lexp.isSame(r.left)) then { // x + (x + y)
						return object ArithmaticExp {
							left := object ArithmaticExp {
								left := 2.makeExp();
								right := r.left;
								op := 'MUL';
							};
							right := r.right;
							op := 'ADD';
						};
					}
					endif;
					if (lexp.isSame(r.right)) then { // x + (y + x)
						return object ArithmaticExp {
							left := object ArithmaticExp {
								left := 2.makeExp();
								right := r.right;
								op := 'MUL';
							};
							right := r.left;
							op := 'ADD';
						};
					}
					endif;
				}	
				case (lexp.isSame(rexp))
				{
					return object ArithmaticExp {
						left := 2.makeExp();
						right := rexp;
						op := 'MUL';
					};
				}
				case ((lexp.oclIsKindOf(ArithmaticExp) and lexp.oclAsType(ArithmaticExp).op = 'MUL') or
					(rexp.oclIsKindOf(ArithmaticExp) and rexp.oclAsType(ArithmaticExp).op = 'MUL'))
				{
					var l : ArithmaticExp; 
					if (lexp.oclIsKindOf(ArithmaticExp)) then {
						l := lexp.oclAsType(ArithmaticExp);
					}
					else {
						l := object ArithmaticExp {
							left := 1.makeExp();
							right := lexp;
							op := 'MUL';
						};
					}
					endif;
					var r : ArithmaticExp;
					if (rexp.oclIsKindOf(ArithmaticExp)) then {
						r := rexp.oclAsType(ArithmaticExp);
					}
					else {
						r := object ArithmaticExp {
							left  := 1.makeExp();
							right := rexp;
							op := 'MUL';
						};
					}
					endif;
					var factor : OCLExpression;
					var lpart : OCLExpression;
					var rpart : OCLExpression;

					if l.op = 'MUL' and r.op = 'MUL' then {
						switch {
							case (l.left.isSame(r.left))
							{
								factor := l.left.simplify();
								lpart := l.right.simplify();
								rpart := r.right.simplify();
							}
							case (l.right.isSame(r.right))
							{
								factor := l.right.simplify();
								lpart := l.left.simplify();
								rpart := r.left.simplify();	
							}
							case (l.left.isSame(r.right))
							{
								factor := l.left.simplify();
								lpart := l.right.simplify();
								rpart := r.left.simplify();
							}
							else
							{
								return self;
							}
						}
					}
					else {
						return object ArithmaticExp {
							left := object ArithmaticExp {
								left := l;
								right := r.left;
								op := 'ADD';
							}.simplify();
							right := r.right;
							op := r.op;
						}.simplify();
					}
					endif;
					return object ArithmaticExp {
						left := factor.simplify();
						right := object ArithmaticExp {
							left := lpart;
							right := rpart;
							op := 'ADD';
						}.simplify();
						op := 'MUL';
					}.simplify();
				}
			};
		}
		case (self.op = 'SUB')
		{
			switch {
				case (lexp.oclIsKindOf(IntegerLiteralExp) and 
						rexp.oclIsKindOf(IntegerLiteralExp))
				{
					return object IntegerLiteralExp {
						integerSymbol := 
							lexp.oclAsType(IntegerLiteralExp).integerSymbol -
							rexp.oclAsType(IntegerLiteralExp).integerSymbol
						;
					};
				}
				case (rexp.oclIsKindOf(IntegerLiteralExp) and 
						rexp.oclAsType(IntegerLiteralExp).integerSymbol = 0)
				{
					return lexp;
				}
				case (lexp.oclIsKindOf(IntegerLiteralExp) and 
						lexp.oclAsType(IntegerLiteralExp).integerSymbol = 0)
				{
					return object ArithmaticExp {
						left := rexp;
						right := null;
						op := 'NEG';
					}.simplify();
				}
				case (lexp.isSame(rexp))
				{
					return 0.makeExp();
				}
				case (rexp.oclIsKindOf(IntegerLiteralExp))
				{
					var rval := rexp.oclAsType(IntegerLiteralExp).integerSymbol;
					if rval < 0 then {
						return object ArithmaticExp {
							left := lexp;
							right := (-rval).makeExp();
							op := 'ADD';
						};
					}
					endif;
					return object ArithmaticExp {
						left := lexp;
						right := rexp;
						op := 'SUB';
					};
				}
				
			}
		}
		case (self.op = 'MUL')
		{
			switch {
				case ((rexp.oclIsKindOf(IntegerLiteralExp) and 
						rexp.oclAsType(IntegerLiteralExp).integerSymbol = 0) or
					  (lexp.oclIsKindOf(IntegerLiteralExp) and 
						lexp.oclAsType(IntegerLiteralExp).integerSymbol = 0))
				{
					return object IntegerLiteralExp {
						integerSymbol := 0;
					};
				}
				case (rexp.oclIsKindOf(IntegerLiteralExp) and
						rexp.oclAsType(IntegerLiteralExp).integerSymbol = 1) 
				{
					return lexp;
				}	
				case (lexp.oclIsKindOf(IntegerLiteralExp) and
						lexp.oclAsType(IntegerLiteralExp).integerSymbol = 1) 
				{
					return rexp;
				}	
				case (lexp.oclIsKindOf(IntegerLiteralExp) and 
						rexp.oclIsKindOf(IntegerLiteralExp))
				{
					return object IntegerLiteralExp {
						integerSymbol := 
							lexp.oclAsType(IntegerLiteralExp).integerSymbol *
							rexp.oclAsType(IntegerLiteralExp).integerSymbol
						;
					};
				}
				case (rexp.oclIsKindOf(IntegerLiteralExp))
				{
					return object ArithmaticExp {
						left := rexp;
						right := lexp;
						op := 'MUL';
					}.simplify();
				}
				case (lexp.oclIsKindOf(ArithmaticExp) and 
						lexp.oclAsType(ArithmaticExp).op = 'MUL')
				{
					return object ArithmaticExp {
						left := lexp.oclAsType(ArithmaticExp).left.simplify();
						right := object ArithmaticExp {
							left := lexp.oclAsType(ArithmaticExp).right;
							right := rexp;
							op := 'MUL';
						}.simplify();
						op := 'MUL';
					}.simplify();
				}
				case (lexp.oclIsKindOf(VariableExp) and 
						rexp.oclIsKindOf(ArithmaticExp))
				{
					var l := object ArithmaticExp {
						left := lexp;
						right := rexp;
						op := 'MUL';
					};
					if (rexp.oclIsKindOf(ArithmaticExp)) then {
						var r := rexp.oclAsType(ArithmaticExp);
						l.right := r.left;
						return object ArithmaticExp {
							left := l.simplify();
							right := r.right;
							op := 'MUL';
						}.simplify();
					}
					else {
						return l.simplify();
					}
					endif;
				}	

			};			
		}
		case (self.op = 'DIV')
		{
			switch {
				case (rexp.oclIsKindOf(IntegerLiteralExp) and
						rexp.oclAsType(IntegerLiteralExp).integerSymbol = 0)
				{
					return null;
				}
				case (lexp.oclIsKindOf(IntegerLiteralExp) and
						lexp.oclAsType(IntegerLiteralExp).integerSymbol = 0)
				{
					return lexp;
				}
				case (lexp.isSame(rexp)) 
				{
					return 1.makeExp();
				}
				case (rexp.oclIsKindOf(IntegerLiteralExp) and
						lexp.oclIsKindOf(IntegerLiteralExp)) 
				{
					//return object IntegerLiteralExp {
					//	integerSymbol := 
					//		(lexp.oclAsType(IntegerLiteralExp).integerSymbol /
					//		rexp.oclAsType(IntegerLiteralExp).integerSymbol).floor()
					//	;
					//};
					return self;
				}
				case (lexp.oclIsKindOf(ArithmaticExp) and 
						lexp.oclAsType(ArithmaticExp).op = 'MUL')
				{
					var l := lexp.oclAsType(ArithmaticExp);
					return object ArithmaticExp {
						left := l.left;
						right := object ArithmaticExp {
							left := l.right;
							right := rexp;
							op := 'DIV';
						};
						op := 'MUL';
					}.simplify();
				}
			};	
		}
		case (self.op = 'NEG')
		{
			switch {
				case (lexp.oclIsKindOf(IntegerLiteralExp)) {
					return (-(lexp.oclAsType(IntegerLiteralExp).integerSymbol)).makeExp();
				}
				case (lexp.oclIsKindOf(ArithmaticExp))
				{
					var l := lexp.oclAsType(ArithmaticExp);
					switch {
							case (l.op = 'NEG') 
							{
								return l.left.simplify();
							}
							case (l.op = 'ADD')
							{
								return object ArithmaticExp {
									left := object ArithmaticExp {
										left := l.left.simplify();
										op := 'NEG';
									};
									right := object ArithmaticExp {
										left := l.right.simplify();
										op := 'NEG';
									};	
									op := 'SUB';
								}.simplify();
							}
							case (l.op = 'SUB')
							{
								return object ArithmaticExp {
									left := object ArithmaticExp {
										left := l.left.simplify();
										op := 'NEG';
									};
									right := object ArithmaticExp {
										left := l.right.simplify();
										op := 'NEG';
									};	
									op := 'ADD';
								}.simplify();
							}
					};
				}	
			};
		}
	};
	return object ArithmaticExp {
		left := lexp;
		right := rexp;
		op := self.op
	};
}





/////////////////////// QvtEval ////////////////////////////////////////////////////////
property helpers : OrderedSet(Helper) = null;
property mappings : OrderedSet(MappingOperation) = null;
property properties : OrderedSet(EAttribute) = null;
property configProperties : OrderedSet(EAttribute) = null;
property usedModelTypes : OrderedSet(ModelType) = null;
property mappingCallLevel : Integer = 0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  Classes
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

intermediate class Environment {
	localEnv : Dict(String, Frame);
	parentEnv : Environment;
}

constructor Environment::Environment() {
	localEnv := Dict{};
	parentEnv := null;
}


///////////////////////////////////////////////////////////////////////////////
//
// createEnvironment
//
///////////////////////////////////////////////////////////////////////////////

helper createEnvironment() : Environment {
	return new Environment();
}

constructor Environment::Environment(parent : Environment) {
	localEnv := Dict {};
	parentEnv := parent;
}


///////////////////////////////////////////////////////////////////////////////
//
// createEnvironment
//
///////////////////////////////////////////////////////////////////////////////

helper createEnvironment(parent : Environment) : Environment {
	return new Environment(parent);
}

constructor Environment::Environment(name : String, val : OclAny, parent : Environment ) {
	parentEnv := parent;
	localEnv := Dict {};
	localEnv->put(name, createFrame(val));
}


///////////////////////////////////////////////////////////////////////////////
//
// createEnvironment
//
///////////////////////////////////////////////////////////////////////////////

helper createEnvironment(name : String, val : OclAny, parent : Environment) : Environment {
	return new Environment(name, val, parent);
}

///////////////////////////////////////////////////////////////////////////////
//
// Enviroment::getRootEnv
//
///////////////////////////////////////////////////////////////////////////////

helper Environment::getRootEnv() : Environment {
	var env := self;
	while (env.parentEnv <> null) {
		env := env.parentEnv;	
	};
	return env;
}


///////////////////////////////////////////////////////////////////////////////
//
// Environment::hasKey
//
///////////////////////////////////////////////////////////////////////////////

helper Environment::hasKey(name : String) : Boolean {
	if (self.localEnv->hasKey(name)) then {
		return true;
	}
	endif;
	return self.parentEnv.hasKey(name);
}


///////////////////////////////////////////////////////////////////////////////
//
// Environment::put
//
///////////////////////////////////////////////////////////////////////////////

helper Environment::put(name : String, val : Frame) : Environment {
	if  (not self.localEnv->hasKey(name)) and self.parentEnv.hasKey(name) then {
			self.parentEnv->put(name, val);	
	}
	else {
			self.localEnv->put(name, val);		
	}
	endif;
	return self;
}


///////////////////////////////////////////////////////////////////////////////
//
// Environment::get
//
///////////////////////////////////////////////////////////////////////////////

helper Environment::get(name : String) : Frame{
	var env := self;
	while (env <> null and not env.localEnv->hasKey(name)) {
		env := env.parentEnv;
	};
	if (env = null) then {
		return null;
	}
	endif;
	return env.localEnv->get(name);
}


///////////////////////////////////////////////////////////////////////////////
//
// getEnvironment
//
///////////////////////////////////////////////////////////////////////////////

helper getEnvironment(e : OclAny) : Environment {
	if (e.oclIsTypeOf(Environment)) then {
		return e.oclAsType(Environment);
	}
	endif;
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// Environment::copy
//
///////////////////////////////////////////////////////////////////////////////

helper Environment::copy() : Environment {
	var env : Environment := new Environment();
	var local := self.localEnv;
	var goUp := true;
	while (goUp) {
		local->keys()->forEach(k) {
			env.put(k, local->get(k));
		};
		if (self.parentEnv <> null) then {
			env := object Environment {
				parentEnv := env;
			};
			local := self.parentEnv.localEnv;
		}
		else {
			break;
		}
		endif;
	};

	return env;
}

intermediate class Function {};


///////////////////////////////////////////////////////////////////////////////
//
// Function::func
//
///////////////////////////////////////////////////////////////////////////////

helper Function::func(arg : OclAny) : OclAny {
	return null;
}

intermediate class Eq extends Function {};

///////////////////////////////////////////////////////////////////////////////
//
// Eq::func
//
///////////////////////////////////////////////////////////////////////////////

helper Eq::func(arg0 : OclAny, arg1 : OclAny) : OclAny {
	return arg0 = arg1;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function::func
//
///////////////////////////////////////////////////////////////////////////////

helper Function::func(arg0 : OclAny, arg1 : OclAny) : OclAny {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// ImperativeIterateExp::makeCondition
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::makeCondition(env : Environment) : Function {
	var opCall := self.condition.oclAsType(OperationCallExp);
	var opName := opCall.referredOperation.oclAsType(EOperation).name;
	var cond : Function := null;
	if opName = '=' then {
		cond := new Eq();
	}
	endif;
	return cond;
}


///////////////////////////////////////////////////////////////////////////////
//
// ImperativeIterateExp::makeCollector
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::makeCollector(env : Environment) : Function {	
	return null;
}


intermediate class CollectionWrapper extends  EObject {
	set : Set(OclAny);
	seq : Sequence(OclAny);
	ord : OrderedSet(OclAny);
	list : List(OclAny);
	bag : Bag(OclAny);
	type : String;
}

constructor CollectionWrapper::CollectionWrapper(c : Sequence(OclAny)) {
	type := 'Sequence';
	seq := c;	
}

constructor CollectionWrapper::CollectionWrapper(c : OrderedSet(OclAny)) {
	type := 'OrderedSet';
	ord := c;
}

constructor CollectionWrapper::CollectionWrapper(c : Set(OclAny)) {
	type := 'Set';
	set := c;
}

constructor CollectionWrapper::CollectionWrapper(c : List(OclAny)) {
	type := 'List';
	list := c;
}

constructor CollectionWrapper::CollectionWrapper(c : Bag(OclAny)) {
	type := 'Bag';
	bag := c;
}

constructor CollectionWrapper::CollectionWrapper(c : Collection(OclAny)) {
	type := 'Collection';
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::collection() : Collection(OclAny) {
	switch {
		case (self.type = 'Bag') 
			{return self.bag}
		case (self.type = 'List')
			{return self.list}
		case (self.type = 'OrderedSet')
			{return self.ord}
		case (self.type = 'Sequence')
			{return self.seq}
		case (self.type = 'Set')
			{return self.set}
	};
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// createCollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper createCollectionWrapper(c : Bag(OclAny)) : CollectionWrapper {
	return new CollectionWrapper(c);
}


///////////////////////////////////////////////////////////////////////////////
//
// createCollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper createCollectionWrapper(c : Set(OclAny)) : CollectionWrapper {
	return new CollectionWrapper(c);
}


///////////////////////////////////////////////////////////////////////////////
//
// createCollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper createCollectionWrapper(c : OrderedSet(OclAny)) : CollectionWrapper {
	return new CollectionWrapper(c);
}


///////////////////////////////////////////////////////////////////////////////
//
// createCollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper createCollectionWrapper(c : Sequence(OclAny)) : CollectionWrapper {
	return new CollectionWrapper(c);
}


///////////////////////////////////////////////////////////////////////////////
//
// createCollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper createCollectionWrapper(c : List(OclAny)) : CollectionWrapper {
	return new CollectionWrapper(c);
}


///////////////////////////////////////////////////////////////////////////////
//
// getWrappedCollection
//
///////////////////////////////////////////////////////////////////////////////

helper getWrappedCollection(c : OclAny) : Collection(OclAny) {
	if (c.oclIsTypeOf(CollectionWrapper)) then {
		return c.oclAsType(CollectionWrapper).collection();
	}
	endif;
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// getCollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper getCollectionWrapper(c : OclAny) : CollectionWrapper {
	if (c.oclIsTypeOf(CollectionWrapper)) then {
		return c.oclAsType(CollectionWrapper);
	}
	endif;
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// setCollectionWrapper
//
///////////////////////////////////////////////////////////////////////////////

helper setCollectionWrapper(inout c : EObject, col : OrderedSet(OclAny)) {
	if (c.oclIsTypeOf(CollectionWrapper)) then {
		c.oclAsType(CollectionWrapper).ord := col;
	}
	endif;
	
}


///////////////////////////////////////////////////////////////////////////////
//
// OclAny::asSet
//
///////////////////////////////////////////////////////////////////////////////

helper OclAny::asSet() : Set(OclAny) {
	if self.oclIsKindOf(CollectionWrapper)then {
		self.oclAsType(CollectionWrapper).asSet();
	}
	endif;
	return Set{self};
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper::asSet
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::asSet() : Set(OclAny) {
	switch {
		case (self.type = 'Bag') 
			{return self.bag->asSet()}
		case (self.type = 'List')
			{
				var res := Sequence{};
				self.list->forEach(element) {
					res->append(element)
				};
				return res->asSet();
			}
		case (self.type = 'OrderedSet')
			{return self.ord->asSet()}
		case (self.type = 'Sequence')
			{return self.seq->asSet()}
		case (self.type = 'Set')
			{return self.set}
	};
	return null;	
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper::asOrderedSet
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::asOrderedSet() : OrderedSet(OclAny) {
	switch {
		case (self.type = 'Bag') 
			{return self.bag->asOrderedSet()}
		case (self.type = 'List')
			{
				var res := OrderedSet{};
				self.list->forEach(element) {
					res->append(element)
				};
				return res;
			}
		case (self.type = 'OrderedSet')
			{return self.ord}
		case (self.type = 'Sequence')
			{return self.seq->asOrderedSet()}
		case (self.type = 'Set')
			{return self.set->asOrderedSet()}
	};
	return null;	
}

///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper::asBag
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::asBag() : Bag(OclAny) {
	switch {
		case (self.type = 'Bag') 
			{return self.bag}
		case (self.type = 'List')
			{
				var res := OrderedSet{};
				self.list->forEach(element) {
					res->append(element)
				};
				return res->asBag();
			}
		case (self.type = 'OrderedSet')
			{return self.ord->asBag()}
		case (self.type = 'Sequence')
			{return self.seq->asBag()}
		case (self.type = 'Set')
			{return self.set->asBag()}
	};
	return null;	
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper::asList
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::asList() : List(OclAny) {
	switch {
		case (self.type = 'Bag') 
			{return self.bag->asList()}
		case (self.type = 'List')
			{return self.list}
		case (self.type = 'OrderedSet')
			{return self.ord->asList()}
		case (self.type = 'Sequence')
			{return self.seq->asList()}
		case (self.type = 'Set')
			{return self.set->asList()}
	};
	return null;	
}




///////////////////////////////////////////////////////////////////////////////
//
// CollectonWrapper::print
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::print() : String {
	var output : String =  '['; 
	if (self.collection()->notEmpty()) then {
		var firstObj := self.collection()->any(true);
		output := output + firstObj.repr();
		//self.collection->
		self.collection()->forEach(e| e <> firstObj){
			output := output + ', ' + e.repr();
		};
	}
	endif;
	return output + ']';
}

intermediate class FrameFactory {
	static instance : FrameFactory;
};



///////////////////////////////////////////////////////////////////////////////
//
// creteFrame
//
///////////////////////////////////////////////////////////////////////////////

helper createFrame(val : OclAny) : Frame {
	switch {
		case (val.oclIsKindOf(EObject)) 
			{return new ObjectFrame(val.oclAsType(EObject))}
		case (val.oclIsKindOf(Integer)) 
			{return new IntegerFrame(val.oclAsType(Integer))}
		case (val.oclIsKindOf(String))
			{return new StringFrame(val.oclAsType(String))}
		case (val.oclIsKindOf(Boolean))
			{return new BooleanFrame(val.oclAsType(Boolean))}
		else {return new Frame(val)}
	};
	return null;
}

///////////////////////////////////////////////////////////////////////////////
//
// updateFrame
//
///////////////////////////////////////////////////////////////////////////////


helper updateFrame(frame : ObjectFrame, val : EObject) : Frame {
	return new ObjectFrame(val);
}


///////////////////////////////////////////////////////////////////////////////
//
// updateFrame
//
///////////////////////////////////////////////////////////////////////////////

helper updateFrame(frame : IntegerFrame, val : Integer) : Frame {
	return new IntegerFrame(val);
}

intermediate class Frame {
	type : AnyType;
	scope : Integer;
	binding : String;
	anyValue : OclAny;
}

constructor Frame::Frame(val : OclAny) {
	anyValue := val;
}

///////////////////////////////////////////////////////////////////////////////
//
// Frame::value
//
///////////////////////////////////////////////////////////////////////////////

helper Frame::value() : OclAny {
	return self.anyValue;
}

intermediate class ObjectFrame extends Frame{
	objValue : EObject;
}
constructor ObjectFrame::ObjectFrame(val : EObject) {
	objValue := val;
}


///////////////////////////////////////////////////////////////////////////////
//
// ObjectFrame::value
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectFrame::value() : OclAny {
	return self.objValue;
}

intermediate class IntegerFrame extends Frame {
	intValue : Integer;
}

constructor IntegerFrame::IntegerFrame(val : Integer) {
	intValue := val;
}


///////////////////////////////////////////////////////////////////////////////
//
// IntegerFrame::value
//
///////////////////////////////////////////////////////////////////////////////

helper IntegerFrame::value() : OclAny {
	return self.intValue;
}

intermediate class StringFrame extends Frame {
	strValue : String;
}

constructor StringFrame::StringFrame(val : String) {
	strValue := val;
}


///////////////////////////////////////////////////////////////////////////////
//
// StringFrame::value
//
///////////////////////////////////////////////////////////////////////////////

helper StringFrame::value() : OclAny {
	return self.strValue;
}

intermediate class BooleanFrame extends Frame {
	boolValue : Boolean;
}

constructor BooleanFrame::BooleanFrame(val : Boolean) {
	boolValue := val;
}


///////////////////////////////////////////////////////////////////////////////
//
// BooleanFrame::value
//
///////////////////////////////////////////////////////////////////////////////

helper BooleanFrame::value() : OclAny {
	return self.boolValue;
}


///////////////////////////////////////////////////////////////////////////////
//
// OclAny::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper OclAny::invoke(op : EOperation, args : Sequence(OclAny)) : OclAny {
	var opName := op.name;
	if (not self.oclIsKindOf(CollectionWrapper)) then 
		switch {
			case (opName = '=') {return self = args->first();}
			case (opName = '<>') {return self <> args->first();}
			case (opName = 'asSequence') {return new CollectionWrapper(self->asSequence());}
			case (opName = 'asSet') {return new CollectionWrapper(self->asSet());}
			case (opName = 'asBag') {return new CollectionWrapper(self->asBag());}
			case (opName = 'asOrderedSet') {return new CollectionWrapper(self->asOrderedSet());}
			case (opName = 'asList') {return new CollectionWrapper(self->asList());}

		}
	endif;
	var builtin := self.invoke(opName, args);
	if builtin = null then 
		return nonBuiltinOperationInvoke(self, op, args)
	endif;
	return builtin;
/*	
	self.=();
	self.<>();
	self.oclAsType();
	self.oclIsKindOf();
	self.oclIsTypeOf();
	self.oclIsUndefined();
	self.oclIsInvalid();
	self.oclIsNew();
	self.oclIsInState();
*/

}


///////////////////////////////////////////////////////////////////////////////
//
// OclAny::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper OclAny::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	if self.oclIsKindOf(EObject) then 
		return self.oclAsType(EObject).invoke(opName, args)
	endif;	
	switch {
		case (opName = 'oclAsType')
			{
//				var arg := args->first().oclAsType(TypeType);
				
//				var fc := inMetaModel.rootObjects()[EClass]->asSequence()->first();
//				return self.oclAsType();
			}
	};

	
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// nonBuiltinOperationInvoke
//
///////////////////////////////////////////////////////////////////////////////

helper nonBuiltinOperationInvoke(source : OclAny, op : EOperation, args : Sequence(OclAny)) : OclAny {
	// look-up defined operations 
	// evaluate the operation body for the source and args
	var srcObj := source.oclAsType(EObject);
	var srcClass := srcObj.eClass();
	var res := srcObj.eInvoke(op, args->oclAsType(EObject));
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// String::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper String::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = '=')
			{return self = args->first().oclAsType(String)}
		case (opName = '<>')
			{return self <> args->first().oclAsType(String)}
		case (opName = 'size')
			{return self.size()}
		case (opName = 'concat')
			{return self.concat(args->first().oclAsType(String))}
		case (opName = 'substring')
			{return self.substring(args->first().oclAsType(Integer), args->at(2).oclAsType(Integer))}
		case (opName = 'toInteger')
			{return self.toInteger()}
		case (opName = 'toReal')
			{return self.toReal()}
		case (opName = 'toLower')
			{return self.toLower()}
		case (opName = 'toUpper')
			{return self.toUpper()}
		case (opName = '+') 
			{return self + args->first().oclAsType(String)}
		case (opName = 'addSuffixNumber')
			{return self.addSuffixNumber()}
		case (opName = 'asBoolean')
			{return self.asBoolean()}
		case (opName = 'asFloat') 
			{return self.asFloat()}
		case (opName = 'asInteger')
			{return self.asInteger()}
		case (opName = 'endsWith')
			{return self.endsWith(args->first().oclAsType(String))}
		case (opName = 'equalsIgnoreCase')
			{return self.equalsIgnoreCase(args->first().oclAsType(String))}
		case (opName = 'find')
			{return self.find(args->first().oclAsType(String))}
		case (opName = 'firstToUpper') 
			{return self.firstToUpper()}
		case (opName = 'format')
			{	
				log("format not supported yet");
				assert fatal (true);
			}
		case (opName = 'getStrCounter')
			{return self.getStrCounter(args->first().oclAsType(String))}
		case (opName = 'incrStrCounter')
			{return self.incrStrCounter(args->first().oclAsType(String))}
		case (opName = 'indexOf')
			{return self.indexOf(args->first().oclAsType(String))}
		case (opName = 'isQuoted')
			{return self.isQuoted(args->first().oclAsType(String))}
		case (opName = 'lastToUpper')
			{return self.lastToUpper()}
		case (opName = 'length')
			{return self.length()}
		case (opName = 'match')
			{return self.match(args->first().oclAsType(String))}
		case (opName = 'matchBoolean') 
			{return self.matchBoolean(args->first().oclAsType(Boolean))}
		case (opName = 'matchFloat')
			{return self.matchFloat(args->first().oclAsType(Real))}
		case (opName = 'matchIdentifier')
			{return self.matchIdentifier(args->first().oclAsType(String))}
		case (opName = 'matchInteger')
			{return self.matchInteger(args->first().oclAsType(Integer))}
		case (opName = 'normalizeSpace')
			{return self.normalizeSpace()}
		case (opName = 'replace')
			{return self.replace(args->at(1).oclAsType(String), args->at(2).oclAsType(String))}
		case (opName = 'restartAllStrCounter')
			{return self.restartAllStrCounter()}
		case (opName = 'rfind')
			{return self.rfind(args->first().oclAsType(String))}
		case (opName = 'startsWith')
			{return self.startsWith(args->first().oclAsType(String))}
		case (opName = 'startStrCounter')
			{return self.startStrCounter(args->first().oclAsType(String))}
		case (opName = 'substringAfter')
			{return self.substringAfter(args->first().oclAsType(String))}
		case (opName = 'substringBefore')
			{return self.substringBefore(args->first().oclAsType(String))}
		case (opName = 'quotify')
			{return self.quotify(args->first().oclAsType(String))}
		case (opName = 'trim')
			{return self.trim()}
		case (opName = 'unquotify')
			{return self.unquotify(args->first().oclAsType(String))}
		else 
			{
				
			}
	};
	return null;	
}




///////////////////////////////////////////////////////////////////////////////
//
// Integer::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper Integer::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = '<') 
			{return self < args->first().oclAsType(Integer)}
		case (opName = '>')
			{return self > args->first().oclAsType(Integer)}
		case (opName = '=' )
			{return self = args->first().oclAsType(Integer)}
		case (opName = '<>') 
			{return self <> args->first().oclAsType(Integer)}
		case (opName = '>=')
			{return self >= args->first().oclAsType(Integer)}
		case (opName = '<=')
			{return self <= args->first().oclAsType(Integer)}
		case (opName = '+')
			{return self + args->first().oclAsType(Integer)}
		case (opName = '-')
			{
				if args->size() = 0 then {
					return (-self);
				}
				else {
					return self - args->first().oclAsType(Integer);
				}
				endif;
			}
		case (opName = 'div') 
			{return self.div(args->first().oclAsType(Integer))}
		case (opName = 'mod')
		    {return self.mod(args->first().oclAsType(Integer))}
		case (opName = '*')
			{return self * args->first().oclAsType(Integer)}
		case (opName = '/')
			{return self / args->first().oclAsType(Integer)}
		case (opName = 'abs')
			{return self.abs()}
		case (opName = 'toString')
			{return self.toString()}
		else
			{	
			}
	};
	return null;	
}



///////////////////////////////////////////////////////////////////////////////
//
// Boolean::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper Boolean::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = '=')
			{return self = args->first().oclAsType(Boolean)}
		case (opName = '<>')
			{return self <> args->first().oclAsType(Boolean)}
		case (opName = 'not')
			{return self.not()}
		case (opName = 'and')
			{return self and args->first().oclAsType(Boolean)}
		case (opName = 'or')
			{return self or args->first().oclAsType(Boolean)}
		case (opName = 'implies')
			{return self implies args->first().oclAsType(Boolean)}
		case (opName = 'xor')
			{return self xor args->first().oclAsType(Boolean)}
		else 
			{
			}
	};
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// Real::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper Real::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = '=')
			{return self = args->first().oclAsType(Real)}
		case (opName = '<>')
			{return self <> args->first().oclAsType(Real)}
		case (opName = '>')
			{return self > args->first().oclAsType(Real)}
		case (opName = '<')
			{return self < args->first().oclAsType(Real)}
		case (opName = '<=')
			{return self <= args->first().oclAsType(Real)}
		case (opName = '>=')
			{return self >= args->first().oclAsType(Real)}
		case (opName = '+')
			{return self + args->first().oclAsType(Real)}
		case (opName = '-')
			{return self - args->first().oclAsType(Real)}
		case (opName = '*')
			{return self * args->first().oclAsType(Real)}
		case (opName = '/')
			{return self / args->first().oclAsType(Real)}
		case (opName = 'max')
			{return self.max(args->first().oclAsType(Real))}
		case (opName = 'min')
			{return self.min(args->first().oclAsType(Real))}
		case (opName = 'abs')
			{return self.abs()}
		case (opName = 'floor')
			{return self.floor()}
		case (opName = 'round')
			{return self.round()}
		case (opName = 'toString')
			{return self.toString()}
		else 
			{
			}
	};
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// Model::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper Model::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = 'copy')
			{return self.copy()}
		case (opName = 'createEmptyModel')
			{return self.createEmptyModel()}
		case (opName = 'objects')
			{return new CollectionWrapper(self.objects())}
		case (opName = 'objectsOfType')
			{
				var arg := args->first().oclAsType(EClassifier);
				var res := self.objects()->oclAsType(EObject)->xselect(o|o.eClass().name = arg.name)->asOrderedSet();
				return new CollectionWrapper(res);
			}
		case (opName = 'removeElement') 
			{ return self.removeElement(args->first().oclAsType(Element))}
		case (opName = 'rootObjects')
			{return new CollectionWrapper(self.rootObjects())}
		case (opName = '=')
			{return self = args->first()}
		case (opName = '<>')
			{return self <> args->first()}
		
	};
	/*
	self.asTransformation();
	self.copy();
	self.createEmptyModel();
	self.objects();
	self.objectsOfType();
	self.removeElement();
	self.rootObjects();
	self.=();
	self.<>();
	self.oclAsType();
	self.oclIsKindOf();
	self.oclIsTypeOf();
	self.oclIsUndefined();
	self.oclIsInvalid();
	self.oclIsNew();
	self.oclIsInState();
	*/
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// EObject::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper ecore::EObject::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = 'oclIsKindOf') 
			{
				var typeArg := args->first().oclAsType(EClass);
				return typeArg.name = self.eClass().name;
			}
		case (opName = 'oclAsType')
			{
				var typeArg := args->first().oclAsType(EClass);
				if typeArg.name = self.eClass().name then 
					return self
				endif;
				return null;
			}
	};
	/*
	self.oclAsType();
	self.oclIsKindOf();
	self.eClass();
	self.eIsProxy();
	self.eResource();
	self.eContainer();
	self.eContainingFeature();
	self.eContainmentFeature();
	self.eContents();
	self.eAllContents();
	self.eCrossReferences();
	self.eGet();
	self.eGet();
	self.eSet();
	self.eIsSet();
	self.eIsSet();
	self.eUnset();
	self.eInvoke();
	self.=();
	self.<>();
	*/
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper::invoke
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::invoke(opName : String, args : Sequence(OclAny)) : OclAny {
	var c := self.collection();
	switch {
		case (opName = 'count') { return c->count(args->first()); }
		case (opName = 'excludes') {return c->excludes(args->first());}
		case (opName = 'excludesAll') 
			{
				var a := args->first()->asSequence();
				return c->excludesAll(a);
			}
		case (opName = 'includes') {return c->includes(args->first());}
		case (opName = 'includesAll') {return c->includesAll(args->first()->asSequence());}
		case (opName = 'isEmpty') {return c->isEmpty();}
		case (opName = 'notEmpty') {return c->notEmpty();}
		case (opName = 'product') {return new CollectionWrapper(c->product(args->first()->asSequence()));}
		case (opName = 'sum') {return c->sum();}
		case (opName = 'size') {return c->size();}
		else 
			{
				switch 
				{
					case (self.type = 'Bag')
						{
							return bagInvoke(self.bag, opName, args);
						}
					case (self.type = 'Set')
						{
							return setInvoke(self.set, opName, args);	
						}
					case (self.type = 'OrderedSet') 
						{
							return ordInvoke(self.ord, opName, args);
						}
					case (self.type = 'Sequence') 
						{
							return seqInvoke(self.seq, opName, args);
						}
					case (self.type = 'List') 
						{
							return listInvoke(self.list, opName, args);
						}
			
				};
			}
				
	};	
	
/*	
	c->exists();
	c->forAll();
	c->isUnique();
	c->one();
	c->any();
	c->collect();
	c->closure();
*/
}


///////////////////////////////////////////////////////////////////////////////
//
// listInvoke
//
///////////////////////////////////////////////////////////////////////////////

helper listInvoke(list : List(OclAny), opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = 'append') 
			{
				list->append(args->first());
				return new CollectionWrapper(list);
			}
		case (opName = 'prepend') 
			{
				list->prepend(args->first());
				return new CollectionWrapper(list);	
			}
		case (opName = 'insertAt') 
			{
				list->insertAt(
						args->first(),
						args->at(2).oclAsType(Integer)
				);
				return new CollectionWrapper(list);
			}
		case (opName = 'joinfields') 
			{
				list->joinfields(
					args->first().oclAsType(String),
					args->at(2).oclAsType(String),
					args->at(3).oclAsType(String)
				);
			}
		case (opName = 'xselect' or opName = 'select')
			{
				var expr := args->at(2).oclAsType(ImperativeIterateExp);
				var env := args->first().oclAsType(Environment);
				var iteratorname := expr.iterator->first().oclAsType(Variable).name;
				var col :=
					list->xselect(i_|
						expr.condition.eval(
							new Environment(iteratorname, i_, env)
						).oclAsType(Boolean)
				);
				var resList : List(OclAny) := List{};
				col->forEach(e) {
					resList->append(e);	
				};
				return new CollectionWrapper(resList);
			}
	};
	return null;
}



///////////////////////////////////////////////////////////////////////////////
//
// seqInvoke
//
///////////////////////////////////////////////////////////////////////////////

helper seqInvoke(seq : Sequence(OclAny), opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = '=') {return seq = args->first()->asSequence();}
		case (opName = '<>') {return seq <> args->first()->asSequence();}
		case (opName = 'union') {return new CollectionWrapper(seq->union(args->first()->asSequence()));}
		case (opName = 'append') {return new CollectionWrapper(seq->append(args->first()));}
		case (opName = 'prepend') {return new CollectionWrapper(seq->prepend(args->first()));}
		case (opName = 'insertAt') 
			{
				return new CollectionWrapper(
					seq->insertAt(
						args->first().oclAsType(Integer), 
						args->at(2)
					)
				);
			}
		case (opName = 'subSequence') 
			{
				return new CollectionWrapper(
					seq->subSequence(
						args->first().oclAsType(Integer),
						args->at(2).oclAsType(Integer)
					)
				);
			}
		case (opName = 'at') {return seq->at(args->first().oclAsType(Integer));}	
		case (opName = 'indexOf') {return seq->indexOf(args->first());}
		case (opName = 'including') {return seq->includes(args->first());}
		case (opName = 'excluding') {return new CollectionWrapper(seq->excluding(args->first()));}
		case (opName = 'first') 
			{
				var res := seq->first();
				return res;
			}
		case (opName = 'last') {return seq->last();}
		case (opName = 'flatten') {return new CollectionWrapper(seq->flatten());}
		case (opName = 'asSequence') {return new CollectionWrapper(seq);}
		case (opName = 'asSet') {return new CollectionWrapper(seq->asSet());}
		case (opName = 'asBag') {return new CollectionWrapper(seq->asBag());}
		case (opName = 'asOrderedSet') {return new CollectionWrapper(seq->asOrderedSet());}
		case (opName = 'asList') {return new CollectionWrapper(seq->asList());}
		case (opName = 'xselect' or opName = 'select')
			{
				var expr := args->at(2).oclAsType(ImperativeIterateExp);
				var env := args->first().oclAsType(Environment);
				var iteratorname := expr.iterator->first().oclAsType(Variable).name;
				return new CollectionWrapper(
					seq->xselect(i_|
						expr.condition.eval(
							new Environment(iteratorname, i_, env)
						).oclAsType(Boolean)
					)
				);
			}
	};
/*
*/
	
	return null;
}



///////////////////////////////////////////////////////////////////////////////
//
// ordInvoke
//
///////////////////////////////////////////////////////////////////////////////

helper ordInvoke(ord : OrderedSet(OclAny), opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = '=') {return ord = args->first()->asOrderedSet();}
		case (opName = '<>') {return ord <> args->first()->asOrderedSet();}
		case (opName = 'union') {return new CollectionWrapper(ord->union(args->first()->asOrderedSet()));}
		case (opName = 'append') {return new CollectionWrapper(ord->append(args->first()));}
		case (opName = 'prepend') {return new CollectionWrapper(ord->prepend(args->first()));}
		case (opName = 'insertAt') 
			{
				return new CollectionWrapper(
					ord->insertAt(
						args->first().oclAsType(Integer), 
						args->at(2)
					)
				);
			}
			case (opName = 'subOrderedSet') 
			{
				return new CollectionWrapper(
					ord->subOrderedSet(
						args->first().oclAsType(Integer),
						args->at(2).oclAsType(Integer)
					)
				);
			}
		case (opName = 'at') {return ord->at(args->first().oclAsType(Integer));}	
		case (opName = 'indexOf') {return ord->indexOf(args->first());}
		case (opName = 'including') {return ord->includes(args->first());}
		case (opName = 'excluding') {return new CollectionWrapper(ord->excluding(args->first()));}
		case (opName = '-') {return new CollectionWrapper(ord - args->first()->asOrderedSet());}
		case (opName = 'union') {return new CollectionWrapper(ord->union(args->first()->asSet()));}
		case (opName = 'intersection') {return new CollectionWrapper(ord->intersection(args->first()->asSet()));}
		case (opName = 'symmetricDifference') {return new CollectionWrapper(ord->symmetricDifference(args->first()->asSet()));}
		case (opName = 'first') {return ord->first();}
		case (opName = 'last') {return ord->last();}
		case (opName = 'flatten') {return new CollectionWrapper(ord->flatten());}
		case (opName = 'asSequence') {return new CollectionWrapper(ord->asSequence());}
		case (opName = 'asSet') {return new CollectionWrapper(ord->asSet());}
		case (opName = 'asBag') {return new CollectionWrapper(ord->asBag());}
		case (opName = 'asOrderedSet') {return new CollectionWrapper(ord);}
		case (opName = 'asList') {return new CollectionWrapper(ord->asList());}
		case (opName = 'xselect' or opName = 'select')
			{
				var expr := args->at(2).oclAsType(ImperativeIterateExp);
				var env := args->first().oclAsType(Environment);
				var iteratorname := expr.iterator->first().oclAsType(Variable).name;
				return new CollectionWrapper(
					ord->xselect(i_|
						expr.condition.eval(
							new Environment(iteratorname, i_, env)
						).oclAsType(Boolean)
					)
				);
			}
	};

/*	
*/
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// setInvoke
//
///////////////////////////////////////////////////////////////////////////////

helper setInvoke(set : Set(OclAny), opName : String, args : Sequence(OclAny)) : OclAny {
	var firstArg : Set(OclAny);
	if args->first().oclIsKindOf(CollectionWrapper) then {
		firstArg := args->first().asSet();
	}
	else {
		firstArg := args->first()->asSet();
	}
	endif;
	switch {
		case (opName = '=') {return set = firstArg;}
		case (opName = '<>') {return set <> firstArg;}
		case (opName = 'union') {return new CollectionWrapper(set->union(firstArg));}
		case (opName = 'intersection') {return new CollectionWrapper(set->intersection(firstArg));}
		case (opName = '-') {return new CollectionWrapper(set - firstArg);}
		case (opName = 'including') {return set->includes(args->first());}
		case (opName = 'excluding') {return new CollectionWrapper(set->excluding(args->first()));}
		case (opName = 'symmetricDifference') {return new CollectionWrapper(set->symmetricDifference(firstArg));}
		case (opName = 'flatten') {return new CollectionWrapper(set->flatten());}
		case (opName = 'asSequence') {return new CollectionWrapper(set->asSequence());}
		case (opName = 'asSet') {return new CollectionWrapper(set);}
		case (opName = 'asBag') {return new CollectionWrapper(set->asBag());}
		case (opName = 'asOrderedSet') {return new CollectionWrapper(set->asOrderedSet());}
		case (opName = 'asList') {return new CollectionWrapper(set->asList());}
		case (opName = 'xselect' or opName = 'select')
			{
				var expr := args->at(2).oclAsType(ImperativeIterateExp);
				var env := args->first().oclAsType(Environment);
				var iteratorname := expr.iterator->first().oclAsType(Variable).name;
				return new CollectionWrapper(
					set->xselect(i_|
						expr.condition.eval(
							new Environment(iteratorname, i_, env)
						).oclAsType(Boolean)
					)
				);
			}
	};
	
	/*
	set->=();
	set-><>();
	set->union();
	set->union();
	set->-();
	set->intersection();
	set->intersection();
	set->including();
	set->including();
	set->intersection();
	set->including();
	set->excluding();
	set->symmetricDifference();
	set->flatten();
	*/
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// bagInvoke
//
///////////////////////////////////////////////////////////////////////////////

helper bagInvoke(bag : Bag(OclAny), opName : String, args : Sequence(OclAny)) : OclAny {
	switch {
		case (opName = '=') {return bag = args->first()->asBag();}
		case (opName = '<>') {return bag <> args->first()->asBag();}
		case (opName = 'union') 
			{
				return new CollectionWrapper(
					bag->union(
						args->first()->asBag()
					)
				);
				
			}
		case (opName = 'intersection') {return new CollectionWrapper(bag->intersection(args->first()->asBag()));}
		case (opName = 'including') {return bag->includes(args->first());}
		case (opName = 'excluding') {return new CollectionWrapper(bag->excluding(args->first()));}
		case (opName = 'flatten') {return new CollectionWrapper(bag->flatten());}
		case (opName = 'asSequence') {return new CollectionWrapper(bag->asSequence());}
		case (opName = 'asSet') {return new CollectionWrapper(bag->asSet());}
		case (opName = 'asBag') {return new CollectionWrapper(bag);}
		case (opName = 'asOrderedSet') {return new CollectionWrapper(bag->asOrderedSet());}
		case (opName = 'asList') {return new CollectionWrapper(bag->asList());}
		case (opName = 'xselect' or opName = 'select')
			{
				var expr := args->at(2).oclAsType(ImperativeIterateExp);
				var env := args->first().oclAsType(Environment);
				var iteratorname := expr.iterator->first().oclAsType(Variable).name;
				return new CollectionWrapper(
					bag->xselect(i_|
						expr.condition.eval(
							new Environment(iteratorname, i_, env)
						).oclAsType(Boolean)
					)
				);
			}
	};

	return null;
}

//helper ecore::EObject::invoke(op : EOperation, args : Sequence(OclAny)) : OclAny {
//	return self.eInvoke(op,args->oclAsType(EObject));
//}



///////////////////////////////////////////////////////////////////////////////
//
// OclAny::print
//
///////////////////////////////////////////////////////////////////////////////

helper OclAny::print() : String {
	return self.repr();
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//  lval Functions
//
/////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::lval
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::OCLExpression::lval(env : Environment) : OclAny {
	return null;	
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::lval
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::expressions::OCLExpression::lval(env : Environment) : OclAny {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableExp::lval
//
///////////////////////////////////////////////////////////////////////////////

helper VariableExp::lval(env : Environment) : OclAny {
	return self.name;
}


///////////////////////////////////////////////////////////////////////////////
//
// PropertyCallExp::lval
//
///////////////////////////////////////////////////////////////////////////////

helper PropertyCallExp::lval(env : Environment) : OclAny {
	return self.source.lval(env);
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//  eval Functions
//
/////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
//
// OperationalTransformation::eval
//
///////////////////////////////////////////////////////////////////////////////

helper OperationalTransformation::eval(env : Environment) : OclAny {
/*
	var operations := self.eOperations->excluding(self.entry);
	var modelParamEnv := new Environment(env);
	self.modelParameter->forEach(m) {
		var modelType := m.eType;
		var modelKind := m.kind;
		if m.kind = DirectionKind::_in then {
			modelParamEnv.put(m.name, createFrame(inModel));		
		}
		else {
			modelParamEnv.put(m.name, createFrame(outModel));			
		}
		endif;
	};

	return self.entry.eval(modelParamEnv);
*/	
	return self.entry.eval(env);
}


///////////////////////////////////////////////////////////////////////////////
//
// EntryOperation::eval
//
///////////////////////////////////////////////////////////////////////////////

helper EntryOperation::eval(env : Environment) : OclAny {
	return self.body.eval(env);
}


///////////////////////////////////////////////////////////////////////////////
//
// OperationBody::eval
//
///////////////////////////////////////////////////////////////////////////////

helper OperationBody::eval(env : Environment) : OclAny {
	var lastVal : OclAny;
	var retVal : OclAny;
	//var retEnv := new Environment('$__return', null, env);
	env.localEnv->put('$__return', null);
	self.content->forEach(statement) {
		lastVal := statement.eval(env);
		retVal := env.get('$__return').value();
		if (retVal <> null) then {
			return retVal;
		}
		endif;
	};
	return lastVal;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::expressions::OCLExpression::eval(env : Environment): OclAny {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// ReturnExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ReturnExp::eval(env : Environment) : OclAny {
	var retVal := self.value.eval(env);
	env.put('$__return', createFrame(retVal));
	return retVal;
}


///////////////////////////////////////////////////////////////////////////////
//
// OclAny::toEObject
//
///////////////////////////////////////////////////////////////////////////////

helper OclAny::toEObject() : EObject {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// String::toEObject
//
///////////////////////////////////////////////////////////////////////////////

helper String::toEObject() : EObject {
	return self.oclAsType(EObject);
}


///////////////////////////////////////////////////////////////////////////////
//
// Real::toEObject
//
///////////////////////////////////////////////////////////////////////////////

helper Real::toEObject() : EObject {
	return self.oclAsType(EObject);
}


///////////////////////////////////////////////////////////////////////////////
//
// Integer::toEObject
//
///////////////////////////////////////////////////////////////////////////////

helper Integer::toEObject() : EObject {
	return self.oclAsType(EObject);
}


///////////////////////////////////////////////////////////////////////////////
//
// Boolean::toEObject
//
///////////////////////////////////////////////////////////////////////////////

helper Boolean::toEObject() : EObject {
	return self.oclAsType(EObject);
}


///////////////////////////////////////////////////////////////////////////////
//
// EObject::toEObject
//
///////////////////////////////////////////////////////////////////////////////

helper EObject::toEobject() : EObject {
	return self;
}



///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::OperationCallExp::eval(env : Environment) : OclAny {
	var src := self.source.eval(env);
	
	if self.referredOperation.oclIsKindOf(Helper) then {
		var helpOp := self.referredOperation.oclAsType(Helper);
		var context : Environment := new Environment(env.getRootEnv());
		if not src.oclIsInvalid() then { 
			context := env.localEnv->put('self', createFrame(src));
		}
		endif;
		var i := 1;
		while (i <= self.argument->size()) {
			var arg := self.argument->at(i).eval(env);
			var argName := helpOp.eParameters->at(i).name;
			context.localEnv->put(argName, createFrame(arg));
			i := i + 1;
		};

		return helpOp.body.eval(context);
	}
	endif;
	var args := self.argument->eval(env);	
	var res := src.invoke(self.referredOperation.oclAsType(EOperation), args);	
	return res;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingBody::eval
//
///////////////////////////////////////////////////////////////////////////////

helper MappingBody::eval(env : Environment) : OclAny {
	var initPart := self.initSection.eval(env);	
	var contentPart := self.content->eval(env);	
	var endPart := self.endSection.eval(env);
	var variablePart := self.variable; 
	return contentPart->first();
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingParameter::eval
//
///////////////////////////////////////////////////////////////////////////////

helper MappingParameter::eval(env : Environment) : OclAny {
	var init_ := self.initExpression.eval(env);
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingOperation::eval
//
///////////////////////////////////////////////////////////////////////////////

helper MappingOperation::eval(env : Environment) : OclAny {
	var whenPart := self._when.eval(env)->last().oclAsType(Boolean);
	if  whenPart = false then {
		return null;
	}
	endif;
	var resultVar := self.result.name;
	var resultType := self.result.eType;
	var resFrame := new ObjectFrame(null);
	var resEnv := new Environment(env);
	resEnv.localEnv->put('result', resFrame);
	
	var contextPart := self.context.eval(env);
	
	var bodyPart := self.body.eval(resEnv);
	//var srcType := srcObject.eClass();
	//var feature := srcType.getEStructuralFeature(self.referredProperty.oclAsType(EStructuralFeature).name);
	//return srcObject.eGet(feature);
	
	var res := resEnv.get('result').value().oclAsType(EObject);
	var wherePart := self._where.eval(env);
	return res;
}
 

///////////////////////////////////////////////////////////////////////////////
//
// MappingCallExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper MappingCallExp::eval(env : Environment) : OclAny {
	mappingCallLevel := mappingCallLevel + 1;
	var src := self.source.eval(env);
	var type := self.eType.name;
	var op := self.referredOperation.oclAsType(MappingOperation);
	var args := self.argument->eval(env).oclAsType(CollectionWrapper).collection();
	var newEnv := new Environment('self', src, env); 

	var i := 1;
	while (i <= self.argument->size()) {
		var arg := self.argument->at(i).eval(env);
		var argName := op.eParameters->at(i).name;
		newEnv.put(argName, createFrame(arg));
		i := i + 1;
	};

	var res := op.eval(newEnv);
	mappingCallLevel := mappingCallLevel - 1;
	if mappingCallLevel = 0 and res.oclIsKindOf(EObject) then {
		var resObj := res.oclAsType(EObject);
		resObj.map writeObject();
	}
	endif;
	return res;
}


///////////////////////////////////////////////////////////////////////////////
//
// BlockExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper BlockExp::eval(env : Environment) :OclAny {
	var blockEnv := new Environment(env);
	self.body->eval(blockEnv);
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// LogExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper LogExp::eval(env : Environment) : OclAny {
	if (self.condition = null or self.condition.eval(env).oclAsType(Boolean) <> false) then {
		var output : String := "";
		self.argument->forEach(a) {
			var res := a.eval(env); 
			output := output + a.eval(env).print();
		};
		log(output);
	}
	endif;
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// AssignExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper AssignExp::eval(env : Environment) : OclAny {
	
	var lValue := self.left.lval(env).oclAsType(String);	
	var rValue := self.value->first().eval(env);	
	if (self.left.oclIsKindOf(PropertyCallExp)) then {
		var propExpr := self.left.oclAsType(PropertyCallExp);		
		var srcFrameName := propExpr.source.getName();
		var lFrame := env.get(lValue).oclAsType(ObjectFrame);
		var feature := propExpr.referredProperty.oclAsType(EStructuralFeature);
		var obj := lFrame.value().oclAsType(EObject);
		if rValue.oclIsKindOf(CollectionWrapper) and 
			(feature.upperBound > 1 or feature.upperBound = -1 or 
				feature.eType.oclIsKindOf(CollectionType)) then {
			var col := rValue.oclAsType(CollectionWrapper);
			switch {
				case (col.type = 'Sequence') 
				{setMultiFeature(obj, feature.name, col.seq);}
				case (col.type = 'OrderedSet')
				{setMultiFeature(obj, feature.name, col.ord);}
				case (col.type = 'Bag') 
				{setMultiFeature(obj, feature.name, col.bag);}
				case (col.type = 'Set')
				{setMultiFeature(obj, feature.name, col.set);}
				case (col.type = 'List')
				{setMultiFeature(obj, feature.name, col.list);}
			};
			
		}
		else {
			obj.eSet(feature, rValue);
		}
		endif;
		lFrame.objValue := obj;
		env.put(srcFrameName, lFrame);
	}
	else  
		if (self.left.oclIsKindOf(VariableExp)) then {
			var srcFrameName := self.left.getName();
			env.put(srcFrameName, createFrame(rValue));
		}
		endif
	endif;
	//env.put(lValue.)
	return rValue;
}


///////////////////////////////////////////////////////////////////////////////
//
// IteratorExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper IteratorExp::eval(env : Environment) : OclAny {
	var sourceCol_ := self.source.eval(env).oclAsType(CollectionWrapper);
	var source_ := sourceCol_.collection();
	var type_ := sourceCol_.type;
	var iterator_ := self.iterator;
	var itername := self.iterator->first().oclAsType(Variable).name;	
	var res : OclAny;
	
	switch {
		case (self.name = 'select') {
			//var condition_ : Function := self.makeCondition(env);
			//var arg1 := self.condition.oclAsType(OperationCallExp).argument->first().eval(env);		
			return sourceCol_.invoke(self.name, Sequence{env, self});
/*			
			if type_ = 'List' then {
				var reswrap_ := new CollectionWrapper();
				var resList_ : List(OclAny) := List{};
				var resCol_ : Collection(OclAny);
				if self.condition.oclIsKindOf(TypeExp) then {
									resCol_ := sourceCol_.list->
								xselect(i_|
									self.condition.eval(
										new Environment(itername, i_, env)
									).oclAsType(Boolean)
								);
				}
				endif;
				resCol_ := sourceCol_.list->
								xselect(i_|
									self.condition.eval(
										new Environment(itername, i_, env)
									).oclAsType(Boolean)
								);
				resCol_->forEach(e) {
					resList_->append(e);
				};

				reswrap_.type := 'List';
				reswrap_.list := resList_;
				res := reswrap_;		
			}
			else {
				res := new CollectionWrapper (
						source_->xselect(i_|
							self.condition.eval(
								new Environment(itername, i_, env)
							).oclAsType(Boolean)
						)
				);	
			}
			endif;
*/			
		}
		case (self.name = 'collect') {
			res := new CollectionWrapper(
						source_->xcollect(i_|
									self.body.eval(
										new Environment(itername, i_, env)
									)
						)
			);
			
		}
	};
	return res;
}



///////////////////////////////////////////////////////////////////////////////
//
// ImperativeIterateExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::eval(env : Environment) : OclAny {
	var sourceCol_ := self.source.eval(env).oclAsType(CollectionWrapper);
	var source_ := sourceCol_.collection();
	var type_ := sourceCol_.type;
	var iterator_ := self.iterator;
	var itername := self.iterator->first().oclAsType(Variable).name;	
	var res : OclAny;
	
	switch {
		case (self.name = 'xselect') {
			//var condition_ : Function := self.makeCondition(env);
			//var arg1 := self.condition.oclAsType(OperationCallExp).argument->first().eval(env);		
			return sourceCol_.invoke(self.name, Sequence{env, self});
/*			
			if type_ = 'List' then {
				var reswrap_ := new CollectionWrapper();
				var resList_ : List(OclAny) := List{};
				var resCol_ : Collection(OclAny);
				if self.condition.oclIsKindOf(TypeExp) then {
									resCol_ := sourceCol_.list->
								xselect(i_|
									self.condition.eval(
										new Environment(itername, i_, env)
									).oclAsType(Boolean)
								);
				}
				endif;
				resCol_ := sourceCol_.list->
								xselect(i_|
									self.condition.eval(
										new Environment(itername, i_, env)
									).oclAsType(Boolean)
								);
				resCol_->forEach(e) {
					resList_->append(e);
				};

				reswrap_.type := 'List';
				reswrap_.list := resList_;
				res := reswrap_;		
			}
			else {
				res := new CollectionWrapper (
						source_->xselect(i_|
							self.condition.eval(
								new Environment(itername, i_, env)
							).oclAsType(Boolean)
						)
				);	
			}
			endif;
*/			
		}
		case (self.name = 'xcollect') {
			if (self.body <> null) then {
				res := new CollectionWrapper(
							source_->xcollect(i_|
										self.body.eval(
											new Environment(itername, i_, env)
										)
							)
				);
			}
			else { // if the body is null (e.g., collection type casts)
				res := new CollectionWrapper(source_->xcollect(i_|i_));
			}
			endif;
		}
		case (self.name = 'selectOne') {
			res := source_->selectOne(i_|
								self.condition.eval(
									new Environment(itername, i_, env)
								).oclAsType(Boolean)
			);
		}
		case (self.name = 'collectOne') {
			res := source_->collectOne(i_|
								self.body.eval(
									new Environment(itername, i_, env)
								).oclAsType(Boolean)
			);
		}
		case (self.name = 'collectselect') {
			var target := self.target.oclAsType(Variable).name;
			var iterEnv := new Environment(env);
			res := new CollectionWrapper(
							source_->collectselect(
								i_;
								t = self.body.eval(
										iterEnv.put(itername, createFrame(i_))
									)
								| self.condition.eval(
										iterEnv.put(target, createFrame(t))		
									).oclAsType(Boolean)
							)
			);
		}
		case (self.name = 'collectselecOne') {
			var target := self.target.oclAsType(Variable).name;
			var iterEnv := new Environment(env);
			res := source_->collectselectOne(
								i_;
								t = self.body.eval(
										iterEnv.put(itername, createFrame(i_))
									)
								| self.condition.eval(
										iterEnv.put(target, createFrame(t))
									).oclAsType(Boolean)
			);			
			
		}
	};			
	return res;
}


///////////////////////////////////////////////////////////////////////////////
//
// ForExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ForExp::eval(env : Environment) : OclAny {
	var source_ := self.source.eval(env).oclAsType(CollectionWrapper).collection();
	var itername := self.iterator->first().oclAsType(Variable).name;
	var iterEnv := new Environment(env);
	switch {
		case (self.name = 'forEach') {
			if (self.condition = null) then {
				source_->forEach(i_) {
					self.body.eval(iterEnv.put(itername,createFrame(i_)));
				};
			}
			else {
				source_->forEach(i_|
									self.condition.eval(
										iterEnv.put(
											itername, createFrame(i_)
										)
									).oclAsType(Boolean)
						) {
					self.body.eval(iterEnv);
				};		
			}
			endif;
		}
		case (self.name = 'forOne') {
			if self.condition = null then {
				source_->forOne(i_) {
					self.body.eval(iterEnv.put(itername, createFrame(i_)));
				}
			}
			else {
				source_->forOne(i_|
									self.condition.eval(
										iterEnv.put(
											itername, createFrame(i_)
										)
									).oclAsType(Boolean)
						) {
					self.body.eval(iterEnv);
				};					
			}
			endif;
		}
	};
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// OclAny::makeExp
//
///////////////////////////////////////////////////////////////////////////////

helper OclAny::makeExp() : OCLExpression {
	if self.oclIsKindOf(EObject) then {
		var obj := self.oclAsType(EObject);
		var x := obj.makeExp();
		return x;
	}
	endif;
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::makeExp 
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::makeExp() : OCLExpression {
	return self;
}


///////////////////////////////////////////////////////////////////////////////
//
// EObject::makeExp
//
///////////////////////////////////////////////////////////////////////////////

helper EObject::makeExp() : OCLExpression {
	var path := self.path();
	var objInModel := inputModel.getObject(path);
	var obj := self;
	if objInModel <> null and not objInModel.oclIsInvalid() then {
		obj := path.oclAsType(EObject);
	}
	endif;
	var literalExp : ObjectExp := new ObjectExp();
	literalExp.body := new ConstructorBody();
	obj.eClass().eAllAttributes->forEach(attr) {
		var attrValue : OclAny;
		if (attr.eType.oclIsKindOf(CollectionType)) then {
			var col := Sequence{};
			getMultiFeature(obj, attr.name, col);
			attrValue := new CollectionWrapper(col);
		}
		else {
			attrValue := obj.eGet(attr);
		}
		endif;
		literalExp.body.content += 
			object AssignExp {
				left := object VariableExp {
					referredVariable := object Variable {
						name := attr.name;
					};
					name := referredVariable.oclAsType(Variable).name;
				};
				value := attrValue.makeExp(); 
		};
		literalExp.instantiatedClass := obj.eClass();
	};
	
	return literalExp;
}


///////////////////////////////////////////////////////////////////////////////
//
// Integer::makeExp
//
///////////////////////////////////////////////////////////////////////////////

helper Integer::makeExp() : OCLExpression {
	return object IntegerLiteralExp {
		integerSymbol := self;
	}
}


///////////////////////////////////////////////////////////////////////////////
//
// Real::makeExp
//
///////////////////////////////////////////////////////////////////////////////

helper Real::makeExp() : OCLExpression {
	return object RealLiteralExp {
		realSymbol := self;
	}
}


///////////////////////////////////////////////////////////////////////////////
//
// String::makeExp`
//
///////////////////////////////////////////////////////////////////////////////

helper String::makeExp() : OCLExpression {
	return object StringLiteralExp {
		stringSymbol := self;
	}
}


///////////////////////////////////////////////////////////////////////////////
//
// Boolean::makeExp
//
///////////////////////////////////////////////////////////////////////////////

helper Boolean::makeExp() : OCLExpression {
	return object BooleanLiteralExp {
		booleanSymbol := self;
	}
}



///////////////////////////////////////////////////////////////////////////////
//
// CollectionWrapper::makeExp
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionWrapper::makeExp() : OCLExpression {
	var literalExp := new CollectionLiteralExp();
	
	self.collection()->forEach(element) {
		literalExp.part += 
			object CollectionItem {
				item := element.makeExp();
			};
	};
	switch {
		case (self.type = 'Set')
			{
				literalExp.kind := ocl::expressions::CollectionKind::Set;
				literalExp.eType := object SetType {
					
				};
			}
		case (self.type = 'Sequence')
			{
				literalExp.kind := ocl::expressions::CollectionKind::Sequence;
				literalExp.eType := object SequenceType {
					
				};
			}
		case (self.type = 'OrderedSet')
			{
				literalExp.kind := ocl::expressions::CollectionKind::OrderedSet;
				literalExp.eType := object OrderedSetType {
					
				};
			}
		case (self.type = 'List')
			{
				literalExp.kind := ocl::expressions::CollectionKind::Sequence;
				literalExp.eType := object ListType {
					
				};
			}
		case (self.type = 'Bag')
			{
				literalExp.kind := ocl::expressions::CollectionKind::Bag;
				literalExp.eType := object BagType {
					
				};
			}
	};	
	return literalExp;
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionLiteralExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionLiteralExp::eval(env : Environment) : OclAny {
	var type := self.eType.name;
	var seq : Sequence(OclAny);
	self.part->forEach(p) {
		seq := seq->append(p.oclAsType(CollectionItem).eval(env));
	};
	var res : CollectionWrapper;
	
	switch {
		case (type.startsWith('Set'))
			{res := new CollectionWrapper(seq->asSet())}
		case (type.startsWith('Sequence'))
			{res := new CollectionWrapper(seq)}
		case (type.startsWith('OrderedSet'))
			{res := new CollectionWrapper(seq->asOrderedSet())}
		case (type.startsWith('Bag'))
			{res := new CollectionWrapper(seq->asBag())}
		case (type.startsWith('List'))
			{res := new CollectionWrapper(seq->asList())}			
	};
	return res;
}


///////////////////////////////////////////////////////////////////////////////
//
// StringLiteralExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper StringLiteralExp::eval(env : Environment) : OclAny {
	return self.stringSymbol;
}


///////////////////////////////////////////////////////////////////////////////
//
// IntegerLiteralExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper IntegerLiteralExp::eval(env : Environment) : OclAny {
	return self.integerSymbol;
}


///////////////////////////////////////////////////////////////////////////////
//
// BooleanLiteralExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper BooleanLiteralExp::eval(env : Environment) : OclAny {
	return self.booleanSymbol;
}


///////////////////////////////////////////////////////////////////////////////
//
// RealLiteralExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper RealLiteralExp::eval(env : Environment) : OclAny {
	return self.realSymbol;
}


///////////////////////////////////////////////////////////////////////////////
//
// NullLiteralExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper NullLiteralExp::eval(env : Environment) : OclAny {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionItem::eval
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionItem::eval(env: Environment) : OclAny {
	return self.item.eval(env);
}



///////////////////////////////////////////////////////////////////////////////
//
// PropertyCallExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper PropertyCallExp::eval(env : Environment) : OclAny {	
	var srcObject := self.source.eval(env).oclAsType(EObject);
	var srcType := srcObject.eClass();
	var feature := srcType.getEStructuralFeature(self.referredProperty.oclAsType(EStructuralFeature).name);
	if (feature.upperBound = -1) or (feature.upperBound > 1) or feature.eType.oclIsKindOf(CollectionType) then {
		var subobj := srcObject.allSubobjects();
		//var val := subobj->xselect(obj : EObject|obj.eContainingFeature() = feature);
		var val := Sequence{};
		getMultiFeature(srcObject, feature.name, val);
		var value := new CollectionWrapper(val->asOrderedSet());
//		switch {
//			case (feature.eType.oclIsKindOf(SetType)) value := new CollectionWrapper(val->asSet());
//			case (feature.eType.oclIsKindOf(BagType)) value := new CollectionWrapper(val->asBag());
//			case (feature.eType.oclIsKindOf(OrderedSetType)) value := new CollectionWrapper(val->asOrderedSet());
//			case (feature.eType.oclIsKindOf(SequenceType)) value := new CollectionWrapper(val->asSequence());
//			case (feature.eType.oclIsKindOf(ListType)) value := new CollectionWrapper(val->asList());
//		};
		return value;
	}
	endif;
	var value := srcObject.eGet(feature);
	return value;
}




///////////////////////////////////////////////////////////////////////////////
//
// VariableExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper VariableExp::eval(env : Environment) : OclAny {
	return env.get(self.name).value();
}



///////////////////////////////////////////////////////////////////////////////
//
// VariableInitExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper VariableInitExp::eval(env : Environment) : OclAny {
	var initValue := self.referredVariable.initExpression.eval(env);
	var frame := createFrame(initValue);
	env.localEnv->put(self.referredVariable.name, frame);
	return initValue;
}


///////////////////////////////////////////////////////////////////////////////
//
// WhileExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper WhileExp::eval(env : Environment) : OclAny {
	var res : OclAny := null;
	while(self.condition.eval(env).oclAsType(Boolean)) {
		res := self.body.eval(env);
	};
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// ComputeExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ComputeExp::eval(env : Environment) : OclAny {
	var initValue := self.returnedElement.initExpression.eval(env);
	var context := new Environment(self.returnedElement.name, initValue, env);
	var body := self.body.eval(context);
	var ret := context.get(self.returnedElement.name);
	return ret.value();
}


///////////////////////////////////////////////////////////////////////////////
//
// IfExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper IfExp::eval(env : Environment) : OclAny {
	return 
		if (self.condition.eval(env).oclAsType(Boolean)) then 
			 self.thenExpression.eval(env)		
		else 
			 self.elseExpression.eval(env)
		
		endif;
}


///////////////////////////////////////////////////////////////////////////////
//
// InstantiationExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper InstantiationExp::eval(env : Environment) : OclAny {
	var type := self.instantiatedClass;
	var instance := type.ePackage.eFactoryInstance.create(type);
	return instance;
}


mapping EObject::writeObject() : EObject {
	init{
		var cont := self.eContainer();
		result := self.deepclone().oclAsType(EObject);
	}
}


///////////////////////////////////////////////////////////////////////////////
//
// ObjectExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectExp::eval(env : Environment) : OclAny {
	var type := self.instantiatedClass;
	var instance := type.ePackage.eFactoryInstance.create(type);	
	var newEnv := new Environment(self.referredObject.name, instance, env);
	self.body.eval(newEnv);
	instance := newEnv.get(self.referredObject.name).value().oclAsType(EObject);
	var extFrame := newEnv.get(self.extent.name);
	if extFrame <> null then {
		var extent := extFrame.value().oclAsType(Model);
		if self.referredObject.oclIsKindOf(MappingParameter) then {
			var refObj := self.referredObject.oclAsType(MappingParameter);
			if refObj.name = 'result' then {
				env.put('result', createFrame(instance));
				return instance;				
			}
			endif;
		}
		endif;
		instance.map writeObject();
	}
	endif;
	return instance;
}


///////////////////////////////////////////////////////////////////////////////
//
// TypeExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper TypeExp::eval(env : Environment) : OclAny {
	var type := self.referredType;
	var javatype := self.getType();
	return type;
}


///////////////////////////////////////////////////////////////////////////////
//
// ConstructorBody::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ConstructorBody::eval(env : Environment) : OclAny {
	self.content->eval(env);
	//self.operation;
	//self.variable;
	return null;
}




///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::eval(env : Environment) : OclAny {
	return null;
}
/////////////////////////////// QvtPrettyPrinter ////////////////////////////////////////

property _tab_ : String = '    ';



///////////////////////////////////////////////////////////////////////////////
//
// printTabs
//
///////////////////////////////////////////////////////////////////////////////

helper printTabs(tabs : Integer) : String {
	var i := 0;
	var code := '';
	while (i < tabs) {
		code := code + _tab_;
		i := i + 1;
	}; 
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// printArgs
//
///////////////////////////////////////////////////////////////////////////////

helper printArgs(list : OrderedSet(ecore::EObject)) : String {
	if (list->isEmpty()) then
		return ""
	endif;
	var code : String := list->first().print(0);	
	var rest := list->subOrderedSet(2, list->size());
	rest->forEach(expr) {
		code := code + ', ' + expr.print(0);
	};
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// printArgs
//
///////////////////////////////////////////////////////////////////////////////

helper printArgs(list : OrderedSet(ecore::EModelElement)) : String {
	if (list->isEmpty()) then
		return ""
	endif;
	var code : String := list->first().print(0);	
	var rest := list->subOrderedSet(2, list->size());
	rest->forEach(expr) {
		code := code + ', ' + expr.print(0);
	};
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// printArgs
//
///////////////////////////////////////////////////////////////////////////////

helper printArgs(list : OrderedSet(ocl::expressions::CollectionLiteralPart)) : String {
	if (list->isEmpty()) then
		return ""
	endif;
	var code : String := list->first().print(0);	
	var rest := list->subOrderedSet(2, list->size());
	rest->forEach(expr) {
		code := code + ', ' + expr.print(0);
	};
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// printArgs
//
///////////////////////////////////////////////////////////////////////////////

helper printArgs(list : OrderedSet(ocl::utilities::ASTNode)) : String {
	if (list->isEmpty()) then
		return ""
	endif;
	var code : String := list->first().print(0);	
	var rest := list->subOrderedSet(2, list->size());
	rest->forEach(expr) {
		code := code + ', ' + expr.print(0);
	};
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// printExpressions
//
///////////////////////////////////////////////////////////////////////////////

helper printExpressions(exprList : OrderedSet(ocl::ecore::OCLExpression), tabs : Integer) : String {
	var code : String;
	exprList->forEach(expr) {
		code := code + printTabs(tabs) + expr.print(tabs) + ';\n';
	};
	return code;
}



///////////////////////////////////////////////////////////////////////////////
//
// EObject::print
//
///////////////////////////////////////////////////////////////////////////////

helper ecore::EObject::print(tabs : Integer) : String {
	var nameFeature := self.eClass().getEStructuralFeature('name');
	return self.eGet(nameFeature).oclAsType(String);
}


///////////////////////////////////////////////////////////////////////////////
//
// EstructuralFeature::print
//
///////////////////////////////////////////////////////////////////////////////

helper ecore::EStructuralFeature::print(tabs : Integer) : String {
	var code : String := self.name;
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// EModelElement::print
//
///////////////////////////////////////////////////////////////////////////////

helper ecore::EModelElement::print(tabs : Integer) : String {
	assert(true);
	return "";
}


///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::utilities::ASTNode::print(tabs : Integer) : String {
	assert(true);
	return "";
}


///////////////////////////////////////////////////////////////////////////////
//
// OperationalTransformation::print
//
///////////////////////////////////////////////////////////////////////////////


helper OperationalTransformation::print(tabs : Integer) : String {
	var code : String := "";
	self.usedModelType->reject(mt|mt.name = '_INTERMEDIATE')->forEach(mt) {
		code := code + printTabs(tabs) + mt.print(0);
	};
    code := code + '\n' + printTabs(tabs) + 'transformation ' + self.name + '(';
    code := code + printArgs(self.modelParameter);
  	  	
    code := code + ');\n';
    
    self.configProperty->forEach(p) {
    	code := code + '\nconfiguration property ' + p.name + ' : ' + p.eType.name + ';';
    };
    
    code := code + '\n';
    
    self.intermediateClass->forEach(klass) {
    	code := code + '\nintermediate class ' + klass.name + ' {\n';
    	klass.eAttributes->forEach(attr) {
    		code := code + printTabs(tabs + 1) + attr.name + ' : ' + attr.eType.name + ';\n';
    	};
    	code := code + '}';
    };
    
    code := code + '\n';
    
    self.intermediateProperty->forEach(p) {
    	var cp := p.oclAsType(ContextualProperty);
    	code := code + '\nintermediate property ' + 
    		cp.context.name + '::' + cp.name + ' : ' + cp.eType.name
    	;
    	if cp.initExpression <> null then {
    		code := code + ' = ' + cp.initExpression.print(tabs);	
    	}
    	endif;
    	code := code + ';';
    };
    
    code := code + '\n';
    
    var set := self.eAllStructuralFeatures - self.configProperty;
    
    set->forEach(p|p.oclIsKindOf(EAttribute)) {
    	var pa := p.oclAsType(EAttribute);
    	code := code + '\nproperty ' + pa.name + ' : ' + pa.eType.name;
    	code := code + ' = ' + pa.eAnnotations.contents->first().oclAsType(ocl::ecore::OCLExpression).print(0) + ';'; 
    };
    
    code := code + '\n';

    code := code + '\n' + self.entry.print(tabs);
    self.eOperations->forEach(op | op.oclIsKindOf(MappingOperation)) {
    	code := code + '\n' + op.oclAsType(MappingOperation).print(tabs);	
    };
    self.eOperations->forEach(op | op.oclIsKindOf(Helper)) {
    	code := code + '\n' + op.oclAsType(Helper).print(tabs);
    };
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ModelType::print
//
///////////////////////////////////////////////////////////////////////////////

helper ModelType::print(tabs : Integer) : String {
	var code : String := 'modeltype ' + self.name;
	if (self.conformanceKind != null) then {	
			code := code + ' "' + self.conformanceKind + '"';
	}
	endif;
	code := code + ' uses ';
	var package := self._metamodel->first();
	var meta : String := package.name;
	package := package.eSuperPackage;
	while (package != null) {
		meta := package.name + '::' + meta;
		package := package.eSuperPackage;
	};
	code := code + meta + '(' + self._metamodel->first().nsURI.quotify('\'') + ');' + '\n';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ModelParameter::print
//
///////////////////////////////////////////////////////////////////////////////

helper ModelParameter::print(tabs : Integer) : String {
	var code : String := self.kind.repr() + ' ' + self.name + ': ' + self.eType.name;
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// VarParameter::print
//
///////////////////////////////////////////////////////////////////////////////

helper VarParameter::print(tabs : Integer) : String {
	var code : String := self.name + ' : ' + self.eType.name;
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// EntryOperation::print
//
///////////////////////////////////////////////////////////////////////////////

helper EntryOperation::print(tabs : Integer) : String {
	var code : String = printTabs(tabs) + 'main() {\n';
	code := code + self.body.print(tabs + 1) + printTabs(tabs) + '}\n';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// Helper::print
//
///////////////////////////////////////////////////////////////////////////////

helper Helper::print(tabs : Integer) : String {
	var code : String = printTabs(tabs) + 'helper ';
	if (self.context != null) then { 
		code := code + self.context.eType.name + '::';
	}
	endif;
	code := code + self.name;
	code := code + '(' + printArgs(self.eParameters) + ')';
	code := code + ' : ' + printArgs(self._result) + ' {\n';
	code := code + self.body.print(tabs + 1); 
	code := code + printTabs(tabs) + '}\n';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// Helper::signature
//
///////////////////////////////////////////////////////////////////////////////

helper Helper::signature() : String {
	var code : String;
	if (self.context != null) then { 
		code := code + self.context.eType.name + '::';
	}
	endif;
	code := code + self.name;
	code := code + '(' + printArgs(self.eParameters) + ')';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingParameter::print
//
///////////////////////////////////////////////////////////////////////////////

helper MappingParameter::print(tabs : Integer) : String {
	var code : String := self.name + ' : ' + self.eType.name;
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingOperaion::pring
//
///////////////////////////////////////////////////////////////////////////////

helper MappingOperation::print(tabs : Integer) : String {
	var code : String = printTabs(tabs) + 'mapping ' + self.context.eType.name + '::' + self.name;
	code := code + '(' + printArgs(self.eParameters) + ')';
	code := code + ' : ' + self._result->first().eType.name;
	if (self._when->notEmpty()) then {
		code := code + '\n' + printTabs(tabs) + 'when { ' + self._when->first().print(0);
		var rest := self._when->asSequence()->subSequence(2, self._when->size());
		rest->forEach(expr) {
			code := code + '; ' + expr.print(0);
		};
		code := code + ' }';
	}
	endif;
	code := code + '\n' + printTabs(tabs) + '{\n';
	code := code + self.body.print(tabs + 1);
	code := code + printTabs(tabs) + '}\n'; 
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// OperationBody::print
//
///////////////////////////////////////////////////////////////////////////////

helper OperationBody::print(tabs : Integer) : String {
	var code : String := printExpressions(self.content, tabs);
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingBody::print
//
///////////////////////////////////////////////////////////////////////////////

helper MappingBody::print(tabs : Integer) : String {
	var code : String;
	var needsPopulation := self.initSection->notEmpty();	
	if self.initSection->notEmpty() then {
		code := printTabs(tabs) + 'init {\n';
		code := code + printExpressions(self.initSection, tabs + 1);
		code := code + printTabs(tabs) + '}\n';
	} 
	endif;
	if needsPopulation then {
		code := code + printTabs(tabs) + 'population {\n';
		code := code + printExpressions(self.content, tabs + 1);
		code := code + printTabs(tabs) + '}\n';
	}
	else {
		code := code + printExpressions(self.content, tabs);
	}
	endif;
	if self.endSection->notEmpty() then {
		code := code + printTabs(tabs) + 'end {\n';
		code := code + printExpressions(self.endSection,tabs + 1);
		code := code + printTabs(tabs) + '}\n';
	}
	endif;
	
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingCallExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper MappingCallExp::print(tabs : Integer) : String {
	var code : String := self.source.print(0) + '.' + 'map ';
	code := code + self.referredOperation.print(0) + '(' + printArgs(self.argument) + ')';
	return code;
}



///////////////////////////////////////////////////////////////////////////////
//
// ImperativeIterateExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::print(tabs : Integer) : String {
	var code : String := self.source.print(0) + '->' + 
						 self.name + 
						 '(';
	var iter := self.iterator->first().repr();
	code := code + iter; 
	/*						 						  
	var iter := self.iterator->first().oclAsType(ocl::ecore::Variable);
	code := code + iter.name + ' : ' + iter.eType.name;
	self.iterator->subOrderedSet(2,self.iterator->size())->forEach(it) {
		iter := it.oclAsType(ocl::ecore::Variable);
		code := code + ', ' + iter.name + iter.eType.name;
	};
	*/
	if (self.body != null) then  
		code := code + '|' + self.body.print(0) 
	endif;
	if (self.condition != null) then  
		code := code + '|' + self.condition.print(0) 
	endif;
	code := code + ')';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ImperativeLoopExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeLoopExp::print(tabs : Integer) : String {
	var code : String := self.source.print(0) + '->' + 
						 self.name + 
						 '(';
	var iter := self.iterator->first().repr();
	code := code + iter; 
	/*						 						  
	var iter := self.iterator->first().oclAsType(ocl::ecore::Variable);
	code := code + iter.name + ' : ' + iter.eType.name;
	self.iterator->subOrderedSet(2,self.iterator->size())->forEach(it) {
		iter := it.oclAsType(ocl::ecore::Variable);
		code := code + ', ' + iter.name + iter.eType.name;
	};
	*/
	if (self.condition != null) then {  
		code := code + '|' + self.condition.print(0)
	} 
	endif;
	
	code := code + ')';
	
	if (self.body != null) then  {
		code := code + self.body.print(tabs); 
	} 
	endif;
	
	return code;
}




///////////////////////////////////////////////////////////////////////////////
//
// ObjectExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectExp::print(tabs : Integer) : String {
	var code : String := 'object ';
	if (self.referredObject <> null and 
		self.referredObject.name <> null and 
			self.referredObject.name <> '') then {
		code := code + self.referredObject.name + ' : ';
	}
	endif;
	if (self.instantiatedClass <> null and 
		self.instantiatedClass.name <> null and
		self.instantiatedClass.name <> ''
		) then {
		code := code  + self.instantiatedClass.name
 	}
	else {
		if (self.eType <> null and 
			self.eType.name <> null and 
			self.eType.name <> '') then {
			code := code  + ' : ' + self.eType.name;	
		}
		endif;
	}
	endif;
	if self.extent <> null then {
		code := code + '@' + self.extent.name;
	}
	endif;
	code := code + ' {\n';
	code := code + self.body.print(tabs + 1);
	code := code + printTabs(tabs) + '}';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// SwitchExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper SwitchExp::print(tabs : Integer) : String {
	var code : String := 'switch {\n';
	code := code + printExpressions(self.alternativePart, tabs + 1);
	if (self.elsePart != null) then {
		code := code + '\n' + printTabs(tabs + 1) + 'else ' + self.elsePart.print(tabs + 1);
	} 
	endif;
	code := code + '\n' + printTabs(tabs) + '}';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// AltExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper AltExp::print(tabs : Integer) : String {
	var code : String := 'case ' + ' (' + self.condition.print(0) + ')\n';
	code :=  code + printTabs(tabs) + self.body.print(tabs);
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// AssertExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper AssertExp::print(tabs : Integer) : String {
	var code : String := 'assert(' + self.assertion.print(0) + ')';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// AssignExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper AssignExp::print(tabs : Integer) : String {
	var code : String := self.left.print(0);
	code := code  + ' := ';
	self.value->forEach(expr) {
		code := code  + expr.print(0);
	};
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// BlockExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper BlockExp::print(tabs : Integer) : String {
	var code : String := '{\n'; 
	code := code + printExpressions(self.body,tabs + 1);
	code := code + printTabs(tabs) + '}'; 	
	return code
}


///////////////////////////////////////////////////////////////////////////////
//
// BreakExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper BreakExp::print(tabs : Integer) : String {
	var code : String := 'break';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// CatchExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper CatchExp::print(tabs : Integer) : String {
	var code : String := 'catch';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ComputeExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ComputeExp::print(tabs : Integer) : String {
	var code : String := 'compute(' + self.returnedElement.repr() + ') ';
	code := code + self.body.print(tabs);
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ContinueExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ContinueExp::print(tabs : Integer) : String {
	var code : String := 'continue';
	return code;
}

/*
helper ForExp::print(tabs : Integer) : String {
	var code : String := self.source
	return code;
}
*/



///////////////////////////////////////////////////////////////////////////////
//
// InstantiationExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper InstantiationExp::print(tabs : Integer) : String {
	var code : String := 'InstantiationExpNotImpl';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// DictLiteralPart::print
//
///////////////////////////////////////////////////////////////////////////////

helper DictLiteralPart::print(tabs : Integer) : String {
	var code : String := self.key.print(tabs) + ' = ' + self.value.print(tabs);
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// DictLiteralExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper DictLiteralExp::print(tabs : Integer) : String {
	var code : String := 'Dict { ';
	code := code + printArgs(self.part->asOrderedSet());
	code := code + ' }';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ListLiteralExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ListLiteralExp::print(tabs : Integer) : String {
	var code : String := 'ListLiteralExpNotImpl';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// LogExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper LogExp::print(tabs : Integer) : String {
	var code : String := 'log(' + printArgs(self.argument) + ')';
	return code;
}



///////////////////////////////////////////////////////////////////////////////
//
// RaiseExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper RaiseExp::print(tabs : Integer) : String {
	var code : String := 'raise';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// ReturnExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ReturnExp::print(tabs : Integer) : String {
	var code : String := 'return ' + self.value.print(tabs); 
	return code;
}



///////////////////////////////////////////////////////////////////////////////
//
// TryExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper TryExp::print(tabs : Integer) : String {
	var code : String := 'try';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// Typedef::print
//
///////////////////////////////////////////////////////////////////////////////

helper Typedef::print(tabs : Integer) : String {
	var code : String := 'typedef';
	return code;
}




///////////////////////////////////////////////////////////////////////////////
//
// UnlinkExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper UnlinkExp::print(tabs : Integer) : String {
	var code : String := 'unlink';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// UnpackExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper UnpackExp::print(tabs : Integer) : String {
	var code : String := 'unpack';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableInitExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper VariableInitExp::print(tabs : Integer) : String {
	var code := 'var ' + self.referredVariable.name;
	if (self.referredVariable.eType != null and 
		self.referredVariable.eType.name != null and 
		self.referredVariable.eType.name != '') then {
		code := code +  ' : ' + self.referredVariable.eType.name;			
	}
	endif;
	if (self.referredVariable.initExpression != null) then {
		var iexp := self.referredVariable.initExpression;
		code := code + ' := ' + iexp.print(tabs).replace('\n', ' ').replace('    ', ' ');
	}
	endif;
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// WhileExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper WhileExp::print(tabs : Integer) : String {
	var code : String := 'while (' + self.condition.print(0) + ') ';
	code := code + self.body.print(tabs);
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionLiteralPart::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::expressions::CollectionLiteralPart::print(tabs : Integer) : String {
	return self.repr();
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionItem::print
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionItem::print(tabs : Integer) : String {
	return self.item.print(0);
}


///////////////////////////////////////////////////////////////////////////////
//
// CollectionLiteralExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper CollectionLiteralExp::print(tabs : Integer) : String {
	var code : String := '';
	switch {
		case (self.eType.oclIsTypeOf(SetType) or self.kind = ocl::expressions::CollectionKind::Set)
		{
			code := code + 'Set{';
		}
		case (self.eType.oclIsTypeOf(SequenceType) or self.kind = ocl::expressions::CollectionKind::Sequence)
		{
			code := code + 'Sequence{';
		}
		case (self.eType.oclIsTypeOf(OrderedSetType) or self.kind = ocl::expressions::CollectionKind::OrderedSet)
		{
			code := code + 'OrderedSet{';
		}
		case (self.eType.oclIsTypeOf(BagType) or self.kind = ocl::expressions::CollectionKind::Bag)
		{
			code := code + 'Bag{';
		}
		case (self.eType.oclIsTypeOf(ListType))
		{
			code := code + 'List{'
		}
	} ;
	
	code := code + printArgs(self.part);
	
	code := code + '}';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// TypeExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::TypeExp::print(tabs : Integer) : String {
	var code : String := self.referredType.print(0);
	return code;	
}

/*
helper ocl::ecore::VariableExp::print(tabs : Integer) : String {
	var code := self.name;
	return code;
}

helper ocl::expressions::VariableExp::print(tabs : Integer) : String {
	var code := self.referredVariable.print(0);
	return code;	
}

helper ocl::ecore::Variable::print(tabs : Integer) : String {
	var code := self.name;
	return code;
}

helper ocl::expressions::Variable::print(tabs : Integer) : String {
	var code : String;
	return code;
}




helper ocl::expressions::PropertyCallExp::print(tabs : Integer) : String {
	return null;
}

helper ocl::ecore::TypeExp::print(tabs : Integer) : String {
	var code : String := self.referredType.print(0);
	return code;	
}




helper ocl::ecore::CollectionLiteralExp::print(tabs : Integer) : String {
	var code := self.part->first().oclAsType(ocl::ecore::CollectionItem).item.print(0);
	return code;
}

helper ocl::expressions::CollectionLiteralExp::print(tabs : Integer) : String {
	var code := self.part->first().oclAsType(ocl::ecore::CollectionItem).item.print(0);
	return code;
}


helper ocl::expressions::StringLiteralExp::print(tabs : Integer) : String {
	var code : String := '\'' + self.stringSymbol + '\'';
	return code;
}

helper ocl::ecore::IntegerLiteralExp::print(tabs : Integer) : String {
	var code : String := self.integerSymbol.toString();
	return code;
}

helper ocl::expressions::IntegerLiteralExp::print(tabs : Integer) : String {
	var code : String := self.integerSymbol.toString();
	return code;
}

helper ocl::ecore::BooleanLiteralExp::print(tabs : Integer) : String {
	var code : String := if self.booleanSymbol = true then
							'true'
						 else 
						 	'false'
						 endif;
	return code;
}

helper ocl::ecore::EnumLiteralExp::print(tabs : Integer) : String {
	var code : String := self.eType.name + '::';
	code := code + self.referredEnumLiteral.print(0);
	return code;
}

helper ocl::expressions::BooleanLiteralExp::print(tabs : Integer) : String {
	var code : String := if self.booleanSymbol = true then
							'true'
						 else 
						 	'false'
						 endif;
	return code;
}



helper ocl::ecore::IteratorExp::print(tabs : Integer) : String {
	var code : String := self.source.print(0) + '->' + 
						 self.name + 
						 '(';						  
	var iter := self.iterator->first().oclAsType(ocl::ecore::Variable).print(0);
	code := code + iter; 
	
	//	var iter := self.iterator->first().oclAsType(ocl::ecore::Variable);
	//	code := code + iter.name + ' : ' + iter.eType.name;
	//	self.iterator->subOrderedSet(2,self.iterator->size())->forEach(it) {
	//		iter := it.oclAsType(ocl::ecore::Variable);
	//		code := code + ', ' + iter.name + iter.eType.name;
	//	};
	
	if (self.body != null) then  
		code := code + '|' + self.body.print(0) 
	endif;
	code := code + ')';
	return code;
}
*/


///////////////////////////////////////////////////////////////////////////////
//
// StringLiteralExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::StringLiteralExp::print(tabs : Integer) : String {
	var code : String :=  self.stringSymbol.replace('\n','\\n').replace('\t','\\t').quotify('\'');
	return code;
}



///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::OperationCallExp::print(tabs : Integer) : String {
	var opName := self.referredOperation.oclAsType(ecore::EOperation).name;
	var code : String := '';
	if (self.source <> null) then {
		code := code + self.source.print(0);
			if (opName = '+' or 
				opName = '-' or 
				opName = '/' or 
				opName = '*' or 
				opName = 'div' or 
				opName = 'mod' or 
				opName = '<' or 
				opName = '>' or 
				opName = '>=' or 
				opName = '<=' or 
				opName = '<>' or 
				opName = '=') then {
				code := code + ' ' + opName + ' ' + printArgs(self.argument);
				return code;
			}
			endif;
			var srcType := self.source.getType();
			if (srcType <> null and (srcType.oclIsKindOf(ocl::ecore::CollectionType) or srcType.oclIsKindOf(DictionaryType))) then {
				code := code + '->';
			}
			else {
				code := code + '.';
			}
			endif;
	}
	endif;

	code := code + opName + '(';
	code := code + printArgs(self.argument).replace('\n', ' ') + ')';
	
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// PropertyCallExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::PropertyCallExp::print(tabs : Integer) : String {
	var code : String := self.source.print(0);
	code := code + '.' + self.referredProperty.print(0);
	
	//Sequence{self.referredProperty}->switch(p) {
	//	case (p.oclIsKindOf(EAttribute)) {code := code + '.' + self.referredProperty.oclAsType(EAttribute).name}
	//	case (p.oclIsKindOf(EReference)) {code := code + '.' + self.referredProperty.oclAsType(EReference).name}
	//	else {} 
	//};
	
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// IfExp::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::IfExp::print(tabs : Integer) : String {
	var code : String := 'if ' + '(' + self.condition.print(0) + ')' + ' then ';
	code := code + self.thenExpression.print(tabs) + '\n';
	if self.elseExpression != null then {
		code := code + printTabs(tabs) + 'else ' + self.elseExpression.print(tabs) + '\n';
	}	
	endif;
	code := code + printTabs(tabs) + 'endif';
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::ecore::OCLExpression::print(tabs : Integer) : String {
	var code : String := self.repr();
	return code;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::print
//
///////////////////////////////////////////////////////////////////////////////

helper ocl::expressions::OCLExpression::print(tabs : Integer) : String {
	var code : String := self.repr();
	return code;
}



////////////////////////////// QvtBTA //////////////////////////////////////////////////

intermediate class TransformationContext 
{
	fixedElements : OrderedSet(EObject);
	varElements : OrderedSet(EObject);
	varClasses : OrderedSet(EClass);
	inModel : ModelParameter;
	outModel : ModelParameter;
};

constructor TransformationContext::TransformationContext() {
	
}


///////////////////////////////////////////////////////////////////////////////
//
// createTransformationContext
//
///////////////////////////////////////////////////////////////////////////////

helper createTransformationContext() : TransformationContext {
	return new TransformationContext();
}


///////////////////////////////////////////////////////////////////////////////
//
// OperationalTransformation::bta
//
///////////////////////////////////////////////////////////////////////////////

helper OperationalTransformation::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var inModel : ModelParameter := self.modelParameter->select(mp|mp.kind = DirectionKind::_in)->asSequence()->first();
	var outModel : ModelParameter := self.modelParameter->select(mp|mp.kind = DirectionKind::_out)->asSequence()->first();
	context.inModel := inModel;
	context.outModel := outModel;
	
	var inModelType : EPackage := inModel.eType.oclAsType(ModelType)._metamodel->first();
	var outModelType := outModel.eType.oclAsType(ModelType)._metamodel->first();
	
	var annotations := inModelType.eAnnotations;
	var fixedAnnot := annotations->select(ann|ann.source = 'FIXED')->asSequence()->first();
	var varAnnot := annotations->select(ann|ann.source = 'VAR')->asSequence()->first();
	context.fixedElements := fixedAnnot._references;
	
	varAnnot._references->forEach(element) {
		switch {
			case (element.oclIsTypeOf(EClass))
			{
				context.varClasses += element.oclAsType(EClass);
				break;
			}
			case (element.oclIsTypeOf(EReference))
			{
				var ref := element.oclAsType(EReference);
				context.varClasses += ref.eContainingClass;
			}
			case (element.oclIsTypeOf(EAttribute))
			{
				var attr := element.oclAsType(EAttribute);
				context.varClasses += attr.eContainingClass;
			}
		};

	};
	
	var statements := self.entry.body.content;
	var transBTA := BTAKind::STATIC;
	statements->forEach(expr) {
		if (expr.bta(bt, context) = BTAKind::DYNAMIC) then {
			transBTA := BTAKind::DYNAMIC;
		}
		endif;
	};

	return transBTA;	
}



///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::bta
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	return BTAKind::DYNAMIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// PropertyCallExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper PropertyCallExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var srcBT := self.source.bta(bt, context);
	if srcBT = BTAKind::STATIC then {
		return BTAKind::STATIC;
	}
	endif;
	return BTAKind::MAYBE;
}


///////////////////////////////////////////////////////////////////////////////
//
// LiteralExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper LiteralExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	return BTAKind::STATIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// LogExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper LogExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	return BTAKind::DYNAMIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// ReturnExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper ReturnExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	return self.value.bta(bt, context);
}


///////////////////////////////////////////////////////////////////////////////
//
// AssignExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper AssignExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var valueBT := self.value->first().bta(bt, context);
	if valueBT <> BTAKind::STATIC then {
		return valueBT;
	}
	endif; 	
	return self.left.bta(bt, context);
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper VariableExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	if (bt->hasKey(self.name)) then {
		return bt->get(self.name);
	}
	endif;
	return BTAKind::MAYBE;
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableInitExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper VariableInitExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var varName := self.referredVariable.name;
	var staticReferredVars := 
		self.referredVariable.initExpression.
			allSubobjectsOfType(VariableExp)->
				oclAsType(VariableExp)->
					select(v|bt->get(v.name) = BTAKind::STATIC)
	;
	var dynamicReferredVars :=
		self.referredVariable.initExpression.allSubobjectsOfType(VariableExp)->
			oclAsType(VariableExp)->select(v|bt->get(v.name) = BTAKind::DYNAMIC)
	;
	var initBTA := self.referredVariable.initExpression.bta(bt, context);
	bt->put(varName, initBTA);
	return initBTA;
	
//	if (dynamicReferredVars->size() > 0 ) then {
//		bt->put(varName, BTAKind::DYNAMIC);
//		return BTAKind::DYNAMIC;
//	}
//	else {
//		bt->put(varName, BTAKind::STATIC);
//		return BTAKind::STATIC;
//	}
//	endif;
//	return BTAKind::STATIC;

}


///////////////////////////////////////////////////////////////////////////////
//
// ImperativeIterateExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	return self.source.bta(bt, context);
}


///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper OperationCallExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	if (self.source.oclIsTypeOf(VariableExp) and 
		self.source.oclAsType(VariableExp).name = context.inModel.name) then {
		var modelRef := self.source.oclAsType(VariableExp);
		var op := self.referredOperation.oclAsType(EOperation);
		if (op.name = 'objectsOfType') then {
			var type := self.argument->first().oclAsType(TypeExp).eType.name;
			if (context.varClasses->exists(cl|cl.name = type)) then {
				return BTAKind::DYNAMIC;
			}
			else {
				// CHECK this later: if a type in the input metamodel is not in the var classes 
				// can it be declared as STATIC in all situations?
				return BTAKind::STATIC;
			}
			endif;
		}
		endif;
	}
	endif;
	var srcBTA : BTAKind;
	if (self.source.oclIsTypeOf(VariableExp) and 
		self.source.oclAsType(VariableExp).name = 'this') then {
		srcBTA := BTAKind::STATIC;
	}
	else {
		srcBTA :=  self.source.bta(bt, context);	
	}
	endif;
	var callArgs := self.argument;
	var callArgsBT := callArgs->bta(bt, context);
	var anyNonStaticArg := callArgsBT->exists(t|t <> BTAKind::STATIC);
	if (srcBTA <> BTAKind::STATIC or anyNonStaticArg) then {
		return BTAKind::MAYBE;
	}
	endif;
	
	if not self.referredOperation.oclIsKindOf(Helper) then {
		return BTAKind::STATIC;
	}
	endif;
	
	var helperOp := self.referredOperation.oclAsType(Helper);
	if bt->hasKey(helperOp.signature()) then {
		return BTAKind::STATIC;	
	}
	endif;
	var params := helperOp.eParameters->asOrderedSet();

	var newBt : Dict(String, BTAKind) := Dict{};
	newBt->put(helperOp.signature(), BTAKind::MAYBE);
	bt->keys()->forEach(k) {
		newBt->put(k, bt->get(k));
	};
 	var i := 1;
	var n := params->size();
	while (i <= n) {
		newBt->put(params->at(i).name, callArgsBT->at(i));
		i := i + 1;
	};
	
	newBt->put('self', srcBTA);
	
	var bodyBT := self.referredOperation.oclAsType(Helper).body.content->bta(newBt, context);
	
	if bodyBT->exists(b|b <> BTAKind::STATIC) then {
		return BTAKind::MAYBE;
	}
	endif;
	return BTAKind::STATIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// ConstructorBody::bta
//
///////////////////////////////////////////////////////////////////////////////

helper ConstructorBody::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	if (self.content->bta(bt, context)->exists(x| x <> BTAKind::STATIC)) then {
		return BTAKind::MAYBE;
	}
	endif;
	return BTAKind::STATIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// ObjectExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	return self.body.bta(bt, context);
}


///////////////////////////////////////////////////////////////////////////////
//
// IfExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper IfExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var conditionBT := self.condition.bta(bt, context);
	var thenBT := self.thenExpression.bta(bt, context);
	var elseBT := if self.elseExpression <> null then self.elseExpression.bta(bt, context) else BTAKind::STATIC endif;
	if (conditionBT = BTAKind::STATIC and 
		thenBT = BTAKind::STATIC and 
			elseBT = BTAKind::STATIC) then {
		return BTAKind::STATIC;
	}
	endif;
	if (conditionBT = BTAKind::STATIC) then {
		// if we could eval the condition 
		return BTAKind::MAYBE;
	}
	endif;	
	return BTAKind::DYNAMIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// ForExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper ForExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var srcBT := self.source.bta(bt, context);
	var itername := self.iterator->first().oclAsType(Variable).name;
	if srcBT = BTAKind::STATIC then {
		var newBt : Dict(String, BTAKind) := Dict{};
		bt->keys()->forEach(k) {
			newBt->put(k, bt->get(k));
		};
		newBt->put(itername, srcBT);
		var conditionBT := 
			if (self.condition <> null) then 
				self.condition.bta(newBt, context) 
			else  
				BTAKind::STATIC 
			endif
		;
		if conditionBT = BTAKind::STATIC then {
			var bodyBT := self.body.bta(newBt, context);
			return bodyBT;
		}
		endif;
		
	}
	endif;		
	return srcBT;
}


///////////////////////////////////////////////////////////////////////////////
//
// WhileExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper WhileExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var condBT := self.condition.bta(bt, context);
	if (condBT = BTAKind::STATIC) then {
		return self.body.bta(bt, context);	
	}
	endif;
	return condBT;
}


///////////////////////////////////////////////////////////////////////////////
//
// BlockExp::bta
//
///////////////////////////////////////////////////////////////////////////////

helper BlockExp::bta(bt : Dict(String, BTAKind), inout context : TransformationContext) : BTAKind {
	var bodyBT := self.body->bta(bt, context);
	var blockBT : BTAKind;
	
	if bodyBT->exists(b|b = BTAKind::DYNAMIC) then {
		blockBT := BTAKind::DYNAMIC 
	}
	else {
		if bodyBT->exists(b|b = BTAKind::MAYBE) then {
			blockBT := BTAKind::MAYBE;
		} 
		else {
			blockBT := BTAKind::STATIC;
		}
		endif;
	}	
	endif;
	return blockBT;
}

////////////////////////////////////// QvtMix ///////////////////////////////////////////////
property bindingTimes : Dict(String, BTAKind) = Dict{};
property environment  : Environment = new Environment(); 
property context : TransformationContext = new TransformationContext();

property newOperations : OrderedSet(EOperation) = OrderedSet{};
property memoizeTables : Dict(String, EAttribute) = Dict{};

property tempCount : Integer = 0;
property mixCount : Dict(String, Integer) = Dict{};
property returnFlag : Boolean = false;


property mixTables : Dict(String, Dict(OrderedSet(OclAny), String)) = Dict{};


///////////////////////////////////////////////////////////////////////////////
//
// ImperativeOperation::newMix
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeOperation::newMix() : String {
	var res : String := self.name + '__mix';
	if mixCount->hasKey(self.name) then {
		var n := mixCount->get(self.name);
		n := n + 1;
		mixCount->put(self.name, n);
		res := res + n.print();
	}
	else {
		mixCount->put(self.name, 1);
		res := res + '1';
	}
	endif;
	return res;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingOperation::mappingMixName
//
///////////////////////////////////////////////////////////////////////////////

helper MappingOperation::mappingMixName() : String {
	var res : String := self.name + '__mix';
	if not mixCount->hasKey(self.name) then {
		mixCount->put(self.name, 1);
	}
	endif;
	return res;
}



///////////////////////////////////////////////////////////////////////////////
//
// newTemp
//
///////////////////////////////////////////////////////////////////////////////

helper newTemp() : String {
	tempCount := tempCount + 1;
	return '__temp_' + tempCount.print();
}
     


///////////////////////////////////////////////////////////////////////////////
//
// OperationalTransformation::mix
//
///////////////////////////////////////////////////////////////////////////////

helper OperationalTransformation::mix() : OperationalTransformation {
	environment := createEnvironment();
	//context := createTransformationContext();
	self.modelParameter->forEach(m) {
		bindingTimes->put(m.name, BTAKind::DYNAMIC);
		switch {
			case (m.kind = DirectionKind::_in)
				{
					environment.put(m.name, createFrame(inputModel));
				}
			case (m.kind = DirectionKind::_out)
				{
					environment.put(m.name, createFrame(outputModel));
				}
		}
	};
	var ops := self.eOperations;
	ops := ops->reject(o|o.oclIsKindOf(EntryOperation));

	var res := object OperationalTransformation {
			name := self.name;
			eStructuralFeatures := self.eStructuralFeatures;
			modelParameter := self.modelParameter;
			moduleImport := self.moduleImport;
			usedModelType := self.usedModelType;
			eOperations := ops;		
			intermediateClass := self.intermediateClass;
			intermediateProperty := self.intermediateProperty;
			configProperty := self.configProperty;
		
			var newEntry := self.entry.mix(environment, bindingTimes);
			entry := newEntry;
			eOperations += newEntry;
			eStructuralFeatures += memoizeTables->values();
		};
		newOperations->forEach(o) {
			res.eOperations += o;
		};
		
		return res;
}




///////////////////////////////////////////////////////////////////////////////
//
// EntryOperation::mix
//
///////////////////////////////////////////////////////////////////////////////

helper EntryOperation::mix(env : OclAny, bt : Dict(String, BTAKind)) : EntryOperation {

	tempCount := 0;
	returnFlag := false;
	var ret : EntryOperation := object EntryOperation {
		name := self.name;
		context := self.context;
		body := self.body.mix(env, bt);
	};
	return ret;
}


///////////////////////////////////////////////////////////////////////////////
//
// Helper::mix
//
///////////////////////////////////////////////////////////////////////////////

helper Helper::mix(env : OclAny, bt : Dict(String, BTAKind)) : Helper {
//`	var oldTempCount := tempCount;
	returnFlag := false;
	var resOp := self.deepclone().oclAsType(Helper);
//  moved to OperationCallExp::mixReduce
//	tempCount := 0;
//	resOp.name := resOp.newMix();
	resOp.body := resOp.body.mix(env, bt);
//	tempCount := oldTempCount;
	return resOp;
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingBody::mix
//
///////////////////////////////////////////////////////////////////////////////

helper MappingBody::mix(env : OclAny, bt : Dict(String, BTAKind)) : OperationBody {
	var mixInit : OrderedSet(OCLExpression) := OrderedSet{};
	var originalInit := self.initSection->deepclone().oclAsType(OCLExpression);
	originalInit->forEach(expr) {
		var bindingTime := expr.onlineBta(env, bt);
		if (bindingTime = BTAKind::DYNAMIC) then {
			mixInit += expr.mixReduce(env, bt);
		}
		else {
			mixInit += expr.reduce(env, bt);
		}
		endif;
	};
	var mixPopulation : OrderedSet(OCLExpression) := OrderedSet{};
	var originalPopulation := self.content->deepclone()->oclAsType(OCLExpression);
	originalPopulation->forEach(expr) {
		var bindingTime := expr.onlineBta(env, bt);
		if (bindingTime = BTAKind::DYNAMIC) then {
			mixPopulation += expr.polyMixReduce(env, bt, self.operation);
		}
		else {
			mixPopulation += expr.reduce(env, bt);	
		}
		endif;
	};
	var mixBody : MappingBody := new MappingBody();
	mixBody.content := mixPopulation;
	mixBody.initSection := mixInit;
	
	return mixBody;	
}


///////////////////////////////////////////////////////////////////////////////
//
// MappingOperation::mix
//
///////////////////////////////////////////////////////////////////////////////

helper MappingOperation::mix(env : OclAny, bt : Dict(String, BTAKind)) : MappingOperation {
	var oldTempCount := tempCount;
	tempCount := 0;
	returnFlag := false;
	var ret : MappingOperation := self.deepclone().oclAsType(MappingOperation);
	ret.name := ret.mappingMixName();
	ret.body := ret.body.mix(env, bt);
	ret.eParameters := self.eParameters->deepclone()->oclAsType(EParameter);
	tempCount := oldTempCount;
	return ret;
}



///////////////////////////////////////////////////////////////////////////////
//
// OperationBody::mix
//
///////////////////////////////////////////////////////////////////////////////

helper OperationBody::mix(env : OclAny, bt : Dict(String, BTAKind)) : OperationBody {
		var expressions : OrderedSet(OCLExpression) := OrderedSet{};
		var originalExpr := self.content->deepclone()->oclAsType(OCLExpression);
		originalExpr->forEach(expr) {
			var bindingTime := expr.onlineBta(env, bt);	
			if (bindingTime = BTAKind::DYNAMIC) then {
				expressions += expr.mixReduce(env, bt);
			}
			else {
				expressions += expr.reduce(env, bt);				
			} 
			endif;
			if expressions->last().oclIsTypeOf(ReturnExp) or returnFlag then {
				break;
			}
			endif;
		};
		var mixBody : OperationBody := object OperationBody {
			content := expressions;
		};
		return mixBody;
}


///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::onlineBta
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::onlineBta(env : OclAny, bt : Dict(String, BTAKind)) : BTAKind {
	return BTAKind::STATIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::onlineBta
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::onlineBta(env : OclAny, bt : Dict(String, BTAKind)) : BTAKind {
	return 
		if self.bta(bt, context) = BTAKind::STATIC then 
			BTAKind::STATIC 
		else 
			BTAKind::DYNAMIC 
		endif
	;
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableExp::onlineBta
//
///////////////////////////////////////////////////////////////////////////////

helper VariableExp::onlineBta(env : OclAny, bt : Dict(String, BTAKind)) : BTAKind {
	var offBt := self.bta(bt, context);
	if offBt = BTAKind::MAYBE then {
		if getEnvironment(env).hasKey(self.name) then {
			return BTAKind::STATIC;
		}
		else {
			return BTAKind::DYNAMIC;
		}
		endif;
	}
	endif;
	return offBt;
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableInitExp::onlineBta
//
///////////////////////////////////////////////////////////////////////////////

helper VariableInitExp::onlineBta(env : OclAny, bt : Dict(String, BTAKind)) : BTAKind {
	return self.referredVariable.initExpression.onlineBta(env, bt);
}


///////////////////////////////////////////////////////////////////////////////
//
// IfExp::onlineBta
//
///////////////////////////////////////////////////////////////////////////////

helper IfExp::onlineBta(env : OclAny, bt : Dict(String, BTAKind)) : BTAKind {
	var conditionBt := self.condition.onlineBta(env, bt);
	if conditionBt = BTAKind::STATIC then {
		var condition : Boolean := self.condition.eval(getEnvironment(env)).oclAsType(Boolean);
		if condition then {
			return self.thenExpression.onlineBta(env, bt);
		}
		else {
			if self.elseExpression <> null then {
				return self.elseExpression.onlineBta(env, bt);
			}
			else {
				return BTAKind::STATIC;
			}
			endif;
		}
		endif;
	}
	endif;
	
	var thenBt := self.thenExpression.onlineBta(env, bt);
	var elseBt := self.elseExpression.onlineBta(env, bt);
	if thenBt = BTAKind::STATIC and elseBt = BTAKind::STATIC then {
		var thenVal := self.thenExpression.eval(getEnvironment(env));
		var elseVal := self.elseExpression.eval(getEnvironment(env));
		return 
				if elseVal = thenVal then 
					BTAKind::STATIC 
				else 
					BTAKind::DYNAMIC 
				endif
		;
	}
	endif;
	return BTAKind::DYNAMIC;
}


///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::onlineBta
//
///////////////////////////////////////////////////////////////////////////////

helper OperationCallExp::onlineBta(env : OclAny, bt : Dict(String, BTAKind)) : BTAKind {
	var offBta := self.bta(bt, context);
	if offBta = BTAKind::MAYBE then {
		if self.referredOperation.oclIsKindOf(Helper) then {
			var newBt : Dict(String, BTAKind) := Dict{};
			bt->keys()->forEach(k) {
				newBt->put(k, bt->get(k));
			};
			var params := self.referredOperation.oclAsType(Helper).eParameters->asOrderedSet();
			var callArgs := self.argument;
		
			var i := 1;
			var n := params->size();
			while (i <= n) {
				newBt->put(params->at(i).name, callArgs->at(i).onlineBta(env, bt));
				i := i + 1;
			};
			
			newBt->put('self', self.source.onlineBta(env, bt));
			
			var bodyBT := self.referredOperation.oclAsType(Helper).body.content->bta(newBt, context);
			
			if bodyBT->exists(b|b <> BTAKind::STATIC) then {
				return BTAKind::DYNAMIC;
			}
			endif;
			return BTAKind::STATIC;
		}
		else {
			return BTAKind::DYNAMIC;
		}
		endif;
	}
	endif;
	return offBta;
}


///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::eval
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::eval(env : OclAny, bt : Dict(String, BTAKind)) : OclAny {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::eval
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::eval(env : OclAny, bt : Dict(String, BTAKind)) : OclAny {
	return self.eval(getEnvironment(env));
}



///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::sideEffectsEval
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::sideEffectsEval(env : OclAny, bt : Dict(String, BTAKind), inout effects : EObject) : OclAny {
	return self.eval(env, bt);
}


///////////////////////////////////////////////////////////////////////////////
//
// WhileExp::sideEffectsEval
//
///////////////////////////////////////////////////////////////////////////////

helper WhileExp::sideEffectsEval(env : OclAny, bt : Dict(String, BTAKind), inout effects : EObject) : OclAny {
	var oldEnv := getEnvironment(env);
	var newEnv := oldEnv.copy();
	var body := 
		if (self.body.oclIsKindOf(BlockExp)) then 
			self.body.oclAsType(BlockExp).body
		else 
			OrderedSet{self.body}
		endif
	;
	var vars := body[AssignExp]->
		xcollect(exp|exp.left)->
			xselect(o|o.oclIsKindOf(VariableExp))->
				oclAsType(VariableExp)->
					xcollect(v|v.referredVariable.oclAsType(Variable).name)
	;
	
	self.eval(newEnv);
	var assignments : OrderedSet(OclAny) := OrderedSet{};

	vars->forEach(v) {
		var newVal := newEnv.get(v).value();
		var oldVal := oldEnv.get(v).value();
		if (newVal <> oldVal) then {
			assignments += object AssignExp {
				left := object VariableExp {
					referredVariable := object Variable {
						name := v;
					};
					name := referredVariable.oclAsType(Variable).name;
				};
				value := newVal.makeExp();
			};
		}
		endif;
	};
	
	setCollectionWrapper(effects, assignments);
	return null;	
}


///////////////////////////////////////////////////////////////////////////////
//
// ForExp::sideEffectsEval
//
///////////////////////////////////////////////////////////////////////////////

helper ForExp::sideEffectsEval(env : OclAny, bt : Dict(String, BTAKind), inout effects : EObject) : OclAny {
	var oldEnv := getEnvironment(env);
	var newEnv := oldEnv.copy();
	var body := 
		if (self.body.oclIsKindOf(BlockExp)) then 
			self.body.oclAsType(BlockExp).body 
		else
			OrderedSet{self.body}
		endif
	;
	
	var vars := body[AssignExp]->
		xcollect(exp|exp.left)->
			xselect(o|o.oclIsKindOf(VariableExp))->
				oclAsType(VariableExp)->xcollect(v|v.referredVariable.oclAsType(Variable).name)
	;
	var res := self.eval(newEnv);
	
	var assignments : OrderedSet(OclAny) := OrderedSet{};
	vars->forEach(v) {
		var newVal := newEnv.get(v).value();
		var oldVal := oldEnv.get(v).value();
		if (newVal <> oldVal) then {
			assignments += object AssignExp {
				left := object VariableExp {
					referredVariable := object Variable {
						name := v;
					};
					name := referredVariable.oclAsType(Variable).name;
				};
				value := newVal.makeExp();
			};
		}
		endif;
	};
	
	setCollectionWrapper(effects, assignments);

	return res;
}


///////////////////////////////////////////////////////////////////////////////
//
// IfExp::eval
//
///////////////////////////////////////////////////////////////////////////////

helper IfExp::eval(env : OclAny, bt : Dict(String, BTAKind)) : OclAny {
	if (self.condition.onlineBta(env, bt) = BTAKind::STATIC) then {
		if self.condition.eval(getEnvironment(env)).oclAsType(Boolean) then {
			if self.thenExpression.onlineBta(env, bt) = BTAKind::STATIC then {
				return self.thenExpression.eval(env, bt);
			}
			else {
				return self.thenExpression;
			}
			endif;
		}
		else {
			if self.elseExpression.onlineBta(env, bt) = BTAKind::STATIC then {
				return self.elseExpression.eval(env, bt);
			}
			else {
				return self.elseExpression;
			}
			endif;
		}
		endif;
	}
	endif;	
	if (self.thenExpression.onlineBta(env, bt) = BTAKind::STATIC and
		self.elseExpression.onlineBta(env, bt) = BTAKind::STATIC) then {
		var thenVal := self.thenExpression.eval(env, bt);
		var elseVal := self.elseExpression.eval(env, bt);
		if (elseVal = thenVal) then {
			return thenVal;
		}
		endif;
	}
	endif;
	return self;
		
}


///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::reduce
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::reduce
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{self};
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// WhileExp::reduce
//
///////////////////////////////////////////////////////////////////////////////

helper WhileExp::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var sideEffects := createCollectionWrapper(rewrite);

	self.sideEffectsEval(env, bt, sideEffects);
	sideEffects.collection()->forEach(e) {
		rewrite += e.oclAsType(OCLExpression);
	};
	
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// BlockExp::reducer
//
///////////////////////////////////////////////////////////////////////////////

helper BlockExp::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	self.body->forEach(statement) {
		rewrite += statement.reduce(env, bt);	
	};
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// BlockExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper BlockExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	self.body->forEach(statement) {
		rewrite += statement.mixReduce(env, bt);	
	};
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// IfExp::reduce
//
///////////////////////////////////////////////////////////////////////////////

helper IfExp::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var sideEffects := createCollectionWrapper(rewrite);
	if self.condition.eval(env, bt).oclAsType(Boolean) then {
		rewrite += self.thenExpression.reduce(env, bt);
	}
	else {
		if self.elseExpression <> null then {
			rewrite += self.elseExpression.reduce(env, bt);
		}
		endif;
	}
	endif;
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// IfExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper IfExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var sideEffects := createCollectionWrapper(rewrite);
	if (self.condition.onlineBta(env, bt) = BTAKind::STATIC) then {		
		if self.condition.eval(env, bt).oclAsType(Boolean) then {
			rewrite += self.thenExpression.mixReduce(env, bt);
			if rewrite->last().oclIsKindOf(ReturnExp) then {
				returnFlag := true;	
			}
			endif;
		}
		else {
			rewrite += self.elseExpression.mixReduce(env, bt);
		}
		endif;
	}
	else {
		var condRedex := self.condition.mixReduce(env, bt);
		var ifRedex := self.deepclone().oclAsType(IfExp);
		if (condRedex->size() > 1) then {
			rewrite += condRedex->subOrderedSet(1, condRedex->size() - 1);	
		}
		endif;
		ifRedex.condition := condRedex->last();
		rewrite += ifRedex;
	}
	endif;
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableInitExp::reduce
//
///////////////////////////////////////////////////////////////////////////////

helper VariableInitExp::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var sideEffects := createCollectionWrapper(rewrite);
	var rvalue := self.referredVariable.initExpression.sideEffectsEval(env, bt, sideEffects);
	sideEffects.collection()->forEach(e) {
		rewrite += e.oclAsType(OCLExpression);
	};
	var newInitExp := self.deepclone().oclAsType(VariableInitExp);
	switch {
		case (rvalue.oclIsKindOf(EObject))
		{
			newInitExp.referredVariable.initExpression := 
				rvalue.oclAsType(EObject).makeExp()
			;
			
		}
		else 
		{
			newInitExp.referredVariable.initExpression := rvalue.makeExp();		
		}
	};

	rewrite += newInitExp;
	
	getEnvironment(env).put(self.referredVariable.name, createFrame(rvalue));
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// ReturnExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ReturnExp::mixReduce(env : OclAny ,bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var valMix := self.value.mixReduce(env, bt);
	var newRet := self.deepclone().oclAsType(ReturnExp);
	newRet.value := valMix->last();
	if (valMix->size() > 1) then {
		rewrite += valMix->subOrderedSet(1, valMix->size() - 1);
	}
	endif;
	rewrite += newRet;
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	return null;
}


///////////////////////////////////////////////////////////////////////////////
//
//  OCLExpression::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	return OrderedSet{self};
}


///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	return null;
}

///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	return self.mixReduce(env, bt);
}

///////////////////////////////////////////////////////////////////////////////
//
// VariableInitExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper VariableInitExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var newVarInit := self.deepclone().oclAsType(VariableInitExp);
//	var staticEvalRewrite := self.reduce(env, bt);
	var staticResult := self.eval(env, bt);
	var mixed := self.referredVariable.initExpression.mixReduce(env, bt);
	var mixInit := mixed->last();
	var simplified := mixInit.toArithmaticExp().simplify().toOperationCall();
	var mergeExp := simplified.merge(staticResult, env, bt);
	var newInitExp : OCLExpression := mergeExp->last();
	if mixed->size() > 1 then {
		rewrite += mixed->subOrderedSet(1, mixed->size() - 1);
	}  
	endif;
	if mergeExp->size() >1 then {
		rewrite += mergeExp->subOrderedSet(1, mergeExp->size() - 1);
	}
	endif;

	if newInitExp <> simplified then {
		var subVar := object VariableInitExp {
			referredVariable := object Variable {
				name := self.subName();
				initExpression := newInitExp.oclAsType(OperationCallExp).source;
			};
			name := referredVariable.name;
		};

		bt->put(subVar.referredVariable.name, BTAKind::DYNAMIC);
		subVar.eval(env, bt);
		rewrite += subVar;
		var initWithSubVar := newInitExp.oclAsType(OperationCallExp);
		initWithSubVar.source := object VariableExp {
			referredVariable := subVar.referredVariable.deepclone().oclAsType(Variable);
			name := referredVariable.oclAsType(Variable).name;
			eType := referredVariable.oclAsType(Variable).initExpression.getType().oclAsType(EClassifier);
		};
		newVarInit.referredVariable.initExpression := initWithSubVar.toArithmaticExp().simplify().toOperationCall();	
	}
	else {
		newVarInit.referredVariable.initExpression := newInitExp;	
	}
	endif;
	
	rewrite += newVarInit;
	bt->put(self.referredVariable.name, BTAKind::DYNAMIC);
	
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// VariableInitExp::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper VariableInitExp::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var newVarInit := self.deepclone().oclAsType(VariableInitExp);
//	var staticEvalRewrite := self.reduce(env, bt);
	var staticResult := self.eval(env, bt);
	var staticResultName := '__' + context.name + self.referredVariable.fullName();
	var staticResultCache := staticResultName + 'Cache';
	var selfPath := getEnvironment(env).get('self').value().oclAsType(EObject).path();
	memoizeVariable(staticResultCache, selfPath, staticResult);
	var staticResultLookupExp := makeLookupExp(staticResultCache);
	var cacheType := getCacheType(staticResultCache);	
	if cacheType.indexOf('ObjectPath') > 0 then {
		staticResultLookupExp := object OperationCallExp {
			source := object OperationCallExp { 
				source := staticResultLookupExp.deepclone().oclAsType(OCLExpression);
				referredOperation := object EOperation {
					name := 'getObject';
				}.oclAsType(EObject);	
				argument := OrderedSet{};
				argument += object VariableExp {
					name := this.context.inModel.name;
					referredVariable := object Variable {
						name := this.context.inModel.name;
					};
				}; 
				eType := staticResultLookupExp.eType.deepclone().oclAsType(EClassifier);
			};
			referredOperation := object EOperation {
				name := 'oclAsType';	
			}.oclAsType(EObject);
			eType := staticResultLookupExp.eType.deepclone().oclAsType(EClassifier);
			argument := OrderedSet{};
			argument += object TypeExp {
				referredType := self.referredVariable.eType.getElementType();
			};
		};	
	}
	endif;
	var mixed := self.referredVariable.initExpression.polyMixReduce(env, bt, context);
	var mixedInit := mixed->last();
	var simplified := mixedInit.toArithmaticExp().simplify().toOperationCall().oclAsType(ocl::ecore::OCLExpression);

	var mergeExp := simplified.merge(staticResultLookupExp, env, bt);
	var newInitExp : OCLExpression := mergeExp->last();
	if mixed->size() > 1 then {
		rewrite += mixed->subOrderedSet(1, mixed->size() - 1);
	}  
	endif;
	if mergeExp->size() >1 then {
		rewrite += mergeExp->subOrderedSet(1, mergeExp->size() - 1);
	}
	endif;

	if newInitExp <> simplified then {
		var leftVar := self.referredVariable.deepclone().oclAsType(Variable);
		var subVarName := leftVar.subName();
		var subVarInit := newInitExp.oclAsType(OperationCallExp).source.oclAsType(OCLExpression);
		var subVar : OCLExpression;
		var initWithSubVar := newInitExp.oclAsType(OperationCallExp);
		if getEnvironment(env).hasKey(subVarName) then {
			var subLeftVar := object Variable {
				name := subVarName;
				initExpression := subVarInit;
			};
			subVar := object AssignExp {
				left := object VariableExp {
					name := subVarName;
					referredVariable := subLeftVar;
				};
				value := OrderedSet{subVarInit};
			};
			initWithSubVar.source := object VariableExp {
				referredVariable := subLeftVar;
				name := subVarName;
				eType := referredVariable.oclAsType(Variable).initExpression.getType().oclAsType(EClassifier);
			};
		}
		else {
			var subRefVar := object Variable {
				name := subVarName;
				initExpression := subVarInit;
			};
			subVar := object VariableInitExp {
				referredVariable := subRefVar;
				name := subVarName;
			};
			initWithSubVar.source := object VariableExp {
				referredVariable := subRefVar;
				name := subVarName;
				eType := referredVariable.oclAsType(Variable).initExpression.getType().oclAsType(EClassifier);
			};				
		}
		endif;


		bt->put(subVar.name, BTAKind::DYNAMIC);
		subVar.eval(env, bt);
		rewrite += subVar;
		newVarInit.referredVariable.initExpression := initWithSubVar.toArithmaticExp().simplify().toOperationCall();
	}
	else {
		newVarInit.referredVariable.initExpression := newInitExp;	
	}
	endif;
	newVarInit.referredVariable.eType := newVarInit.referredVariable.initExpression.getType().oclAsType(EClassifier);	
	rewrite += newVarInit;
	bt->put(self.referredVariable.name, BTAKind::DYNAMIC);
	
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::fullName
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::fullName() : String {
	return null;
}

///////////////////////////////////////////////////////////////////////////////
//
// OCLExpresion::fullName
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::fullName() : String {
	return self.name;
}

///////////////////////////////////////////////////////////////////////////////
//
// PropertyCallExp::fullName
//
///////////////////////////////////////////////////////////////////////////////

helper PropertyCallExp::fullName() : String {
	var prop := self.referredProperty.oclAsType(EStructuralFeature).name;
	return '__' + self.source.getName() + '_' + prop;	
}

///////////////////////////////////////////////////////////////////////////////
//
// VariableExp::fullName
//
///////////////////////////////////////////////////////////////////////////////

helper VariableExp::fullName() : String {
	return self.referredVariable.fullName();
}

///////////////////////////////////////////////////////////////////////////////
//
// Variable::fullName
//
///////////////////////////////////////////////////////////////////////////////

helper Variable::fullName() : String {
	return '__' + self.name;
}

///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::subName
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::subName() : String {
	return self.fullName() + 'Sub';
}

///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::subName
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::subName() : String {
	return self.fullName() + 'Sub';
}


///////////////////////////////////////////////////////////////////////////////
//
// AssignExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper AssignExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var newAssign := self.deepclone().oclAsType(AssignExp);
	
//	var staticEvalRewrite := self.reduce(env, bt);
	var staticResult := self.eval(env, bt);
	var mixed : OrderedSet(OCLExpression) := self.value->first().mixReduce(env, bt);
	var mixedValue := mixed->last();
	var simplified := mixedValue.toArithmaticExp().simplify().toOperationCall().oclAsType(ocl::ecore::OCLExpression);
	var mergeExp := simplified.merge(staticResult, env, bt);
	var newValue := mergeExp->last();
	//newAssign.value := OrderedSet{simplified};
	if mixed->size() > 1 then {
		rewrite += mixed->subOrderedSet(1, mixed->size() - 1);
	}
	endif;
	if mergeExp->size() > 1 then {
		rewrite += mergeExp->subOrderedSet(1, mergeExp->size() - 1);
	}
	endif;
	if newValue <> simplified then {
		var leftVar := self.left.deepclone().oclAsType(OCLExpression).reduce(env, bt)->last();
		var subVarName := leftVar.subName();
		var subVarValue := newValue.oclAsType(OperationCallExp).source.oclAsType(OCLExpression);
		var subVar : OCLExpression;
		var valueWithSubVar := newValue.oclAsType(OperationCallExp);
		if getEnvironment(env).hasKey(subVarName) then {
			var subLeftVar := object VariableExp {
				name := subVarName;
				referredVariable := object Variable {
					name := subVarName;
				};
			};
			subVar := object AssignExp {
				left := subLeftVar;
				value := OrderedSet{subVarValue};
			};
			valueWithSubVar.source := object VariableExp {
				referredVariable := subLeftVar.referredVariable;
				name := referredVariable.oclAsType(Variable).name;
				eType := new CollectionType();
			};
		}
		else {
			var subRefVar := object Variable {
				name := subVarName;
				initExpression := subVarValue;
			};
			subVar := object VariableInitExp {
				referredVariable := subRefVar;
				name := subVarName;
			};
			valueWithSubVar.source := object VariableExp {
				referredVariable := subRefVar;
				name := subVarName;
				eType := new CollectionType();
			};
		}
		endif;

		bt->put(subVar.name, BTAKind::DYNAMIC);
		subVar.eval(env, bt);
		rewrite += subVar;
		newAssign.value := OrderedSet{valueWithSubVar.toArithmaticExp().simplify().toOperationCall().oclAsType(OCLExpression)};			
	}
	else {
		newAssign.value := OrderedSet{simplified};
	}
	endif;
	rewrite += newAssign;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// AssignExp::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper AssignExp::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var newAssign := self.deepclone().oclAsType(AssignExp);
	
//	var staticEvalRewrite := self.reduce(env, bt);
	var staticResult := self.eval(env, bt);
	var staticResultName := '__' + context.name + self.left.fullName();
	var staticResultCache := staticResultName + 'Cache';
	var selfPath := getEnvironment(env).get('self').value().oclAsType(EObject).path();
	memoizeVariable(staticResultCache, selfPath, staticResult);
	var staticResultLookupExp := makeLookupExp(staticResultCache);
	
	
	
	var mixed : OrderedSet(OCLExpression) := self.value->first().polyMixReduce(env, bt, context);
	var mixedValue := mixed->last();
	var simplified := mixedValue.toArithmaticExp().simplify().toOperationCall().oclAsType(ocl::ecore::OCLExpression);
	var mergeExp := simplified.merge(staticResultLookupExp, env, bt);
	var newValue := mergeExp->last();
	//newAssign.value := OrderedSet{simplified};
	if mixed->size() > 1 then {
		rewrite += mixed->subOrderedSet(1, mixed->size() - 1);
	}
	endif;
	if mergeExp->size() > 1 then {
		rewrite += mergeExp->subOrderedSet(1, mergeExp->size() - 1);
	}
	endif;
	if newValue <> simplified then {
		var leftVar := self.left.deepclone().oclAsType(OCLExpression).reduce(env, bt)->last();
		var subVarName := leftVar.subName();
		var subVarValue := newValue.oclAsType(OperationCallExp).source.oclAsType(OCLExpression);
		var subVar : OCLExpression;
		var valueWithSubVar := newValue.oclAsType(OperationCallExp);
		if getEnvironment(env).hasKey(subVarName) then {
			var subLeftVar := object VariableExp {
				name := subVarName;
				referredVariable := object Variable {
					name := subVarName;
				};
			};
			subVar := object AssignExp {
				left := subLeftVar;
				value := OrderedSet{subVarValue};
			};
			valueWithSubVar.source := object VariableExp {
				referredVariable := subLeftVar.referredVariable;
				name := referredVariable.oclAsType(Variable).name;
				eType := new CollectionType();
			};
		}
		else {
			var subRefVar := object Variable {
				name := subVarName;
				initExpression := subVarValue;
			};
			subVar := object VariableInitExp {
				referredVariable := subRefVar;
				name := subVarName;
			};
			valueWithSubVar.source := object VariableExp {
				referredVariable := subRefVar;
				name := subVarName;
				eType := new CollectionType();
			};
		}
		endif;

		bt->put(subVar.name, BTAKind::DYNAMIC);
		subVar.eval(env, bt);
		rewrite += subVar;
		newAssign.value := OrderedSet{valueWithSubVar.toArithmaticExp().simplify().toOperationCall().oclAsType(OCLExpression)};			
	}
	else {
		newAssign.value := OrderedSet{simplified};
	}
	endif;
	rewrite += newAssign;
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// AssignExp::reduce
//
///////////////////////////////////////////////////////////////////////////////

helper AssignExp::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var rightBt := self.value->first().onlineBta(env, bt);
	var newAssignment := object AssignExp {
		left := self.left;
		value := self.value->first().eval(env, bt).makeExp();
	};
	rewrite += newAssignment;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// ReturnExp::reduce
//
///////////////////////////////////////////////////////////////////////////////

helper ReturnExp::reduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var newRet := object ReturnExp {
		value := self.value.eval(env, bt).makeExp();
	};
	
	rewrite += newRet;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// ConstructorBody::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ConstructorBody::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var newBody : OrderedSet(OCLExpression) := OrderedSet{};
	self.content->forEach(expr) {
		newBody += expr.mixReduce(env, bt);
	};	
	return newBody;
}

///////////////////////////////////////////////////////////////////////////////
//
// ConstructorBody::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ConstructorBody::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	var newBody : OrderedSet(OCLExpression) := OrderedSet{};
	self.content->forEach(expr) {
		newBody += expr.polyMixReduce(env, bt, context);
	};	
	return newBody;
}

///////////////////////////////////////////////////////////////////////////////
//
// ObjectExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var obj := self.referredObject.name;
	var newBt : Dict(String, BTAKind) := Dict{};
	bt->keys()->forEach(k) {
		newBt->put(k, bt->get(k));
	};
	newBt->put(obj, BTAKind::DYNAMIC);
	var newObjectExp := self.deepclone().oclAsType(ObjectExp);
	newObjectExp.body := object ConstructorBody {
		content := self.body.mixReduce(env, newBt);
	};
	rewrite += newObjectExp;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// ObjectExp::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ObjectExp::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var obj := self.referredObject.name;
	var newBt : Dict(String, BTAKind) := Dict{};
	bt->keys()->forEach(k) {
		newBt->put(k, bt->get(k));
	};
	newBt->put(obj, BTAKind::DYNAMIC);
	var newObjectExp := self.deepclone().oclAsType(ObjectExp);
	newObjectExp.body := object ConstructorBody {
		content := self.body.polyMixReduce(env, newBt, context);
	};
	rewrite += newObjectExp;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// LogExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper LogExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var args : OrderedSet(ocl::expressions::OCLExpression) := OrderedSet{};
	self.argument->forEach(a) {
		var argBt := a.onlineBta(env, bt);
		if (argBt = BTAKind::STATIC) then {
			args += a.eval(env, bt).makeExp();
		}
		else {
			args += a;
		}
		endif;
	};
	var newLog := object LogExp {
		argument := args;
	};
	
	rewrite += newLog;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// MappingCallExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper MappingCallExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var srcBT : BTAKind := self.source.onlineBta(env, bt);
	var argsBT := self.argument->onlineBta(env, bt);
	if argsBT->forAll(t|t = BTAKind::DYNAMIC) and srcBT = BTAKind::DYNAMIC then {
		var srcRedex := self.source.mixReduce(env, bt);
	
		var newCall := self.deepclone().oclAsType(MappingCallExp);

		newCall.source := srcRedex->last().deepclone().oclAsType(OCLExpression);

		var staticResult := self.eval(env, bt);
		var mergeExp := newCall.merge(staticResult, env, bt);
		var s := srcRedex->excluding(srcRedex->last())->asOrderedSet();
		s += mergeExp;		
		rewrite += s;
		
		var newBt : Dict(String, BTAKind) := Dict{};
		bt->keys()->forEach(k) {
			newBt->put(k, bt->get(k));
		};
	
		var params := self.referredOperation.oclAsType(MappingOperation).eParameters->asOrderedSet();
		var callArgs := self.argument;
		
		var funcEnv := createEnvironment();
		funcEnv.parentEnv := getEnvironment(env);
//		var funcEnv := createEnvironment(getEnvironment(env).getRootEnv());
		
	
		
		newBt->put('self', srcBT);
		var srcVal := self.source.eval(env, bt);
		funcEnv.put('self', createFrame(srcVal));
		if (srcBT = BTAKind::STATIC) then {
			funcEnv.put('self', createFrame(srcVal));
			newCall.source := srcVal.makeExp();	
		}
		endif;
		
			
		var newCallArgs : OrderedSet(ocl::expressions::OCLExpression) := OrderedSet{};
		var newParams : OrderedSet(EParameter) := OrderedSet{};
		
		var i := 1;
		var n := params->size();	
		while (i <= n) {
			var arg := callArgs->at(i);
			var param := params->at(i);
			var pbt := arg.onlineBta(env, bt);
			
			newBt->put(param.name, pbt);
			if (pbt = BTAKind::STATIC) then {
				var val := arg.eval(env, bt);
				funcEnv.put(param.name, createFrame(val));
				if (not self.referredOperation.oclIsTypeOf(MappingOperation)) then {
					newCallArgs += val.makeExp();
				}
				endif;
			}
			else {
				newCallArgs += arg.deepclone().oclAsType(OCLExpression);
				newParams += param.deepclone().oclAsType(EParameter);
			}
			endif;
			i := i + 1;
		};
		newCall.argument := newCallArgs;	
		var isFirstMix := not mixCount->hasKey(self.referredOperation.oclAsType(MappingOperation).name);
		var mixedOp := self.referredOperation.oclAsType(MappingOperation).mix(funcEnv, newBt);
		mixedOp.eParameters := newParams;
		newCall.referredOperation := mixedOp.oclAsType(EObject);
		if isFirstMix then {
			newOperations += mixedOp;					
		}
		else {
// 			var refOp := newCall.referredOperation.oclAsType(MappingOperation);
//			refOp.name := refOp.name + '__mix1';
//			newCall.referredOperation := refOp.oclAsType(EObject);
		}
		endif;
	
		rewrite += newCall;
	}
	endif;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper OperationCallExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var srcBT : BTAKind;
	var hasSource := self.source <> null or not self.source.oclIsInvalid();
	if hasSource then {
		srcBT := self.source.onlineBta(env, bt);
	}
	else {
		srcBT := BTAKind::STATIC;
	}
	endif;
	var argsBT := self.argument->onlineBta(env, bt);
	if (argsBT->forAll(b|b = BTAKind::DYNAMIC) and (not hasSource or srcBT = BTAKind::DYNAMIC)) then {
		//return self.reduce(env, bt);
		var srcRedex := self.source.mixReduce(env, bt);
		var newCall := self.deepclone().oclAsType(OperationCallExp);
		var newCallArgs : OrderedSet(OCLExpression) := OrderedSet{};
		self.argument->forEach(arg) {
			if arg.onlineBta(env, bt) = BTAKind::DYNAMIC then {
				newCallArgs += arg.mixReduce(env, bt);	
			}
			else {
				newCallArgs += arg.eval(env, bt).makeExp();
			}
			endif;
		};
		newCall.source := srcRedex->last().deepclone().oclAsType(OCLExpression);
		newCall.argument := newCallArgs;
//		var staticResult := self.eval(env, bt);
//		var mergeExp := newCall.merge(staticResult);
		if srcRedex->size() > 1 then {
			rewrite += srcRedex->subOrderedSet(1, srcRedex->size() - 1);
		}
		endif;
//		var s := srcRedex;//->excluding(srcRedex->last())->asOrderedSet();
//		s += mergeExp;
//		return s;
		rewrite += newCall;		
		return rewrite;
	}
	endif;
	var newBt : Dict(String, BTAKind) := Dict{};
	bt->keys()->forEach(k) {
		newBt->put(k, bt->get(k));
	};

	var params := self.referredOperation.oclAsType(EOperation).eParameters->asOrderedSet();
	var callArgs := self.argument;
	
//	var funcEnv := createEnvironment();
//	funcEnv.parentEnv := getEnvironment(env);
	var funcEnv := createEnvironment(getEnvironment(env).getRootEnv());
	var newCall := self.deepclone().oclAsType(OperationCallExp);

	if (hasSource) then {
		newBt->put('self', srcBT);
		var srcVal := self.source.eval(env, bt);
		funcEnv.put('self', createFrame(srcVal));
		if (srcBT = BTAKind::STATIC) then {
			newCall.source := srcVal.makeExp();	
		}
		else {
			var srcMix := self.source.mixReduce(env, bt);
			if srcMix->size() > 1 then {
				rewrite += srcMix->subOrderedSet(1, srcMix->size() - 1);
			}
			endif;
			newCall.source := srcMix->last();
		}
		endif;
	}	
	endif;
	
	var newCallArgs : OrderedSet(ocl::expressions::OCLExpression) := OrderedSet{};
	var newParams : OrderedSet(EParameter) := OrderedSet{};
	
	var i := 1;
	var n := params->size();	
	var argsKey : OrderedSet(OclAny) := OrderedSet{};
	while (i <= n) {
		var arg := callArgs->at(i);
		var param := params->at(i);
		var pbt := arg.onlineBta(env, bt);
		newBt->put(param.name, pbt);
		var val := arg.eval(env, bt);
		funcEnv.put(param.name, createFrame(val));
		if (pbt = BTAKind::STATIC) then {
			argsKey += val;
			if (not self.referredOperation.oclIsTypeOf(Helper)) then {
				newCallArgs += val.makeExp();
			}
			endif;
		}
		else {
			argsKey += null;
			var argMix := arg.mixReduce(env, bt);
			if argMix->size() > 1 then {
				rewrite += argMix->subOrderedSet(1, argMix->size() - 1);
			}
			endif;
			newCallArgs += argMix->last(); //arg.deepclone().oclAsType(OCLExpression);
			newParams += param.deepclone().oclAsType(EParameter);
		}
		endif;
		i := i + 1;
	};
	newCall.argument := newCallArgs;	
	
	if (not self.referredOperation.oclIsTypeOf(Helper)) then {
		rewrite += newCall;
		return rewrite;
	}
	endif;	
	var opName := self.referredOperation.oclAsType(Helper).name;
	
	if opName.match('__mix') then {	
		opName := opName.substringBefore('__mix');
	}
	endif;
	
	var opTable := mixTables->get(opName);
	if (opTable->hasKey(argsKey)) then {
		newCall.referredOperation := object EOperation {
			name := opTable->get(argsKey);
		}.oclAsType(EObject);
	}
	else {
		if opTable = null then {
			opTable := Dict{};
		}
		endif;
		var oldTempCount := tempCount;
		tempCount := 0;
		var mixName := self.referredOperation.oclAsType(Helper).newMix();
		opTable->put(argsKey, mixName);
		mixTables->put(opName, opTable);
		var mixedOp := self.referredOperation.oclAsType(Helper).mix(funcEnv, newBt);
		tempCount := oldTempCount;
		mixedOp.name := mixName;
		mixedOp.eParameters := newParams;
		newOperations += mixedOp;
		newCall.referredOperation := mixedOp.oclAsType(EObject);
	}
	endif;
	rewrite += newCall;

	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper OperationCallExp::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var srcBT : BTAKind;
	var hasSource := self.source <> null or not self.source.oclIsInvalid();
	if hasSource then {
		srcBT := self.source.onlineBta(env, bt);
	}
	else {
		srcBT := BTAKind::STATIC;
	}
	endif;
	var argsBT := self.argument->onlineBta(env, bt);
	if (argsBT->forAll(b|b = BTAKind::DYNAMIC) and (not hasSource or srcBT = BTAKind::DYNAMIC)) then {
		//return self.reduce(env, bt);
		var srcRedex := self.source.polyMixReduce(env, bt, context);
		var newCall := self.deepclone().oclAsType(OperationCallExp);
		newCall.source := srcRedex->last().deepclone().oclAsType(OCLExpression);
//		var staticResult := self.eval(env, bt);
//		var mergeExp := newCall.merge(staticResult);
		if srcRedex->size() > 1 then {
			rewrite += srcRedex->subOrderedSet(1, srcRedex->size() - 1);
		}
		endif;
//		var s := srcRedex;//->excluding(srcRedex->last())->asOrderedSet();
//		s += mergeExp;
//		return s;
		rewrite += newCall;		
		return rewrite;
	}
	endif;
	var newBt : Dict(String, BTAKind) := Dict{};
	bt->keys()->forEach(k) {
		newBt->put(k, bt->get(k));
	};

	var params := self.referredOperation.oclAsType(EOperation).eParameters->asOrderedSet();
	var callArgs := self.argument;
	
	var funcEnv := createEnvironment();
	funcEnv.parentEnv := getEnvironment(env);
	var newCall := self.deepclone().oclAsType(OperationCallExp);

	if (hasSource) then {
		newBt->put('self', srcBT);

		if (srcBT = BTAKind::STATIC) then {
			var srcVal := self.source.eval(env, bt);
			funcEnv.put('self', createFrame(srcVal));
			newCall.source := srcVal.makeExp();	
		}
		endif;
	}	
	endif;
	
	var newCallArgs : OrderedSet(ocl::expressions::OCLExpression) := OrderedSet{};
	var newParams : OrderedSet(EParameter) := OrderedSet{};
	
	var i := 1;
	var n := params->size();	
	while (i <= n) {
		var arg := callArgs->at(i);
		var param := params->at(i);
		var pbt := arg.onlineBta(env, bt);
		
		newBt->put(param.name, pbt);
		if (pbt = BTAKind::STATIC) then {
			var val := arg.eval(env, bt);
			funcEnv.put(param.name, createFrame(val));
			if (not self.referredOperation.oclIsTypeOf(Helper)) then {
				newCallArgs += val.makeExp();
			}
			endif;
		}
		else {
			newCallArgs += arg.deepclone().oclAsType(OCLExpression);
			newParams += param.deepclone().oclAsType(EParameter);
		}
		endif;
		i := i + 1;
	};
	newCall.argument := newCallArgs;	
	
	if (not self.referredOperation.oclIsTypeOf(Helper)) then {
		rewrite += newCall;
		return rewrite;
	}
	endif;	
	var mixedOp := self.referredOperation.oclAsType(Helper).mix(funcEnv, newBt);
	mixedOp.eParameters := newParams;
	
	newOperations += mixedOp;
	
	newCall.referredOperation := mixedOp.oclAsType(EObject);	

	rewrite += newCall;

	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// ImperativeIterateExp::mixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::mixReduce(env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var srcVariable : VariableInitExp;
	if self.source.oclAsType(ETypedElement).eType.oclIsKindOf(CollectionType) then {
		var srcMix := self.source.mixReduce(env, bt);
		if srcMix->size() > 1 then {
			rewrite += srcMix->subOrderedSet(1, srcMix->size() - 1);
		}
		endif;
		srcVariable := object VariableInitExp {
			referredVariable := object Variable {
				name := newTemp();
				initExpression := srcMix->last().deepclone().oclAsType(OCLExpression);
			};
			name := referredVariable.name;
		};
	}
	else {
		srcVariable := self.makeSourceVariable(newTemp());
	}
	endif;
	var environ := getEnvironment(env);
	
	bt->put(srcVariable.name, BTAKind::DYNAMIC);
	var srcVal := srcVariable.eval(env, bt);	
	rewrite += srcVariable;
	
	var last := getCollectionWrapper(environ.get(srcVariable.referredVariable.name).value()).collection()->size();
	var lastVarName := srcVariable.referredVariable.name + 'Last';
	bt->put(lastVarName, BTAKind::DYNAMIC);
	var lastVar := makeVar(lastVarName, last);	
	var lastVal := lastVar.eval(env, bt);
	rewrite += lastVar;
	
	var sizeVar := makeSizeVar(srcVariable.referredVariable);
	bt->put(sizeVar.name, BTAKind::DYNAMIC);
	var sizeVal := sizeVar.eval(environ, bt);
	rewrite += sizeVar;
	
	var subSetVar := makeSubSetVar(srcVariable.referredVariable);
	bt->put(subSetVar.name, BTAKind::DYNAMIC);
	var subSetVal := subSetVar.eval(env, bt);
	rewrite += subSetVar;
	
	var subSetVarExp := object VariableExp {
		referredVariable := subSetVar.referredVariable.deepclone().oclAsType(Variable);
		name := referredVariable.oclAsType(Variable).name;
	};
	
	var imperativeExp := self.deepclone().oclAsType(ImperativeIterateExp);
	imperativeExp.source := subSetVarExp;
	if self.name = 'xcollect' and self.body.oclIsKindOf(MappingCallExp) then {
		var newBt : Dict(String, BTAKind) = Dict{};
		bt->keys()->forEach(k) {
			newBt->put(k, bt->get(k));
		};
		newBt->put(self.iterator->first().getName(), BTAKind::DYNAMIC);
		var newEnv := createEnvironment(getEnvironment(env));
		var newBody : OCLExpression;

		getCollectionWrapper(self.source.eval(env, newBt)).collection()->forEach(element) {
			newEnv.put(self.iterator->first().getName(), createFrame(element));
			var bodyMix := self.body.mixReduce(newEnv, newBt);
			if bodyMix->size() > 1 then {
				rewrite += bodyMix->subOrderedSet(1, bodyMix->size() - 1);
			}
			endif;
			newBody := bodyMix->last();
		};
		//imperativeExp.body := newBody;
		var union := object OperationCallExp {
			source := imperativeExp;
			referredOperation := object EOperation {
				name := 'union';
			}.oclAsType(EObject);
			argument := OrderedSet{};
			argument += object ImperativeIterateExp {
				name := self.name;				
				source := object OperationCallExp {
					referredOperation := object EOperation {
						name := 'subOrderedSet';
					}.oclAsType(EObject);	
					source := self.source.deepclone().oclAsType(OCLExpression);
					argument := OrderedSet{};
					argument += 1.makeExp();
					argument += object VariableExp {
						referredVariable := lastVar.referredVariable;
						name := lastVar.referredVariable.name;	
					};
				};
				iterator := self.iterator;	
				body := newBody;
				
			};
		};
		rewrite += union;
	}
	else {
		rewrite += imperativeExp;
	}
	endif;
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// ImperativeIterateExp::polyMixReduce
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::polyMixReduce(env : OclAny, bt : Dict(String, BTAKind), context : EOperation) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	var selfPath := getEnvironment(env).get('self').value().oclAsType(EObject).path();
	var srcVariable : VariableInitExp;
	var srcVarName := '__' + context.name + newTemp();
	if self.source.oclAsType(ETypedElement).eType.oclIsKindOf(CollectionType) then {
		var srcMix := self.source.polyMixReduce(env, bt, context);
		if srcMix->size() > 1 then {
			rewrite += srcMix->subOrderedSet(1, srcMix->size() - 1);
		}
		endif;
		srcVariable := object VariableInitExp {
			referredVariable := object Variable {
				name := srcVarName;
				initExpression := srcMix->last().deepclone().oclAsType(OCLExpression);
			};
			name := referredVariable.name;
		};
	}
	else {
		srcVariable := self.makeSourceVariable(srcVarName);
	}
	endif;
	var environ := getEnvironment(env);
	
	bt->put(srcVariable.name, BTAKind::DYNAMIC);
	var srcVal := srcVariable.eval(env, bt);	
	rewrite += srcVariable;
	
	var last := getCollectionWrapper(environ.get(srcVariable.referredVariable.name).value()).collection()->size();
	var lastVarName := srcVarName + 'Last';
	var lastVarCache := lastVarName + 'Cache';
	bt->put(lastVarName, BTAKind::DYNAMIC);
	memoizeVariable(lastVarCache, selfPath, last);
	var lookupExp := makeLookupExp(lastVarCache);
	
	var lastVar := makeVar(lastVarName, lookupExp);	
	//var lastVal := lastVar.eval(env, bt);
	getEnvironment(env).put(lastVarName, createFrame(last));
	rewrite += lastVar;
	
	var sizeVar := makeSizeVar(srcVariable.referredVariable);
	bt->put(sizeVar.name, BTAKind::DYNAMIC);
	var sizeVal := sizeVar.eval(environ, bt);
	rewrite += sizeVar;
	
	var subSetVar := makeSubSetVar(srcVariable.referredVariable);
	bt->put(subSetVar.name, BTAKind::DYNAMIC);
	var subSetVal := subSetVar.eval(env, bt);
	rewrite += subSetVar;
	
	var subSetVarExp := object VariableExp {
		referredVariable := subSetVar.referredVariable.deepclone().oclAsType(Variable);
		name := referredVariable.oclAsType(Variable).name;
	};
	
	var imperativeExp := self.deepclone().oclAsType(ImperativeIterateExp);
	imperativeExp.source := subSetVarExp;
	if self.name = 'xcollect' then {
		var newBt : Dict(String, BTAKind) := Dict{};
		bt->keys()->forEach(k) {
			newBt->put(k, bt->get(k));
		};
		newBt->put(self.iterator->first().getName(), BTAKind::DYNAMIC);
		var newEnv := createEnvironment(getEnvironment(env));
		var newBody : OCLExpression;
		getCollectionWrapper(self.source.eval(env, newBt)).collection()->forEach(element) {
			newEnv.put(self.iterator->first().getName(), createFrame(element));
			var bodyMix := self.body.mixReduce(newEnv, newBt);
			if bodyMix->size() > 1 then {
				rewrite += bodyMix->subOrderedSet(1, bodyMix->size() - 1);
			}
			endif;
			newBody := bodyMix->last();
		};		
		imperativeExp.body := newBody;
	}
	endif;
	rewrite += imperativeExp;
	return rewrite;
}


///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::merge
//
///////////////////////////////////////////////////////////////////////////////


helper ASTNode::merge(val : OclAny, env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	return null;
}

///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::merge
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::merge(val : OclAny, env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	return OrderedSet{self};
}

///////////////////////////////////////////////////////////////////////////////
//
// ASTNode::merge
//
///////////////////////////////////////////////////////////////////////////////

helper ASTNode::getSub(env : OclAny, bt : Dict(String, BTAKind)) : OCLExpression {
	return null;
}

///////////////////////////////////////////////////////////////////////////////
//
// OCLExpression::merge
//
///////////////////////////////////////////////////////////////////////////////

helper OCLExpression::getSub(env : OclAny, bt : Dict(String, BTAKind)) : OCLExpression {
	return self;
}

///////////////////////////////////////////////////////////////////////////////
//
// VariableExp::merge
//
///////////////////////////////////////////////////////////////////////////////

helper VariableExp::getSub(env : OclAny, bt : Dict(String, BTAKind)) : OCLExpression {
	var subName := self.subName();
	if getEnvironment(env).hasKey(subName) then {
		var newVar := object VariableExp {
			name := subName;
			referredVariable := object Variable {
				name := subName;
				eType := self.eType.deepclone().oclAsType(EClassifier);
			};
			eType := referredVariable.oclAsType(Variable).eType;
		};
		return newVar;
	}
	endif;
	return self;
}

///////////////////////////////////////////////////////////////////////////////
//
// OperationCallExp::merge
//
///////////////////////////////////////////////////////////////////////////////

helper OperationCallExp::merge(val : OclAny, env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	if self.referredOperation.oclIsKindOf(Helper) then {
		return OrderedSet{self};
	}
	endif;
	var opName := self.referredOperation.oclAsType(EOperation).name;

	var subSrc := self.source.getSub(env, bt);

	var newCall : OperationCallExp;
	if subSrc <> self.source then {
		newCall := self.deepclone().oclAsType(OperationCallExp);
		newCall.source := subSrc;
	}
	else {
		newCall := self; // var y := 2 * xd should not be replaced by var y:= 2 * xs (the static value of xd), hende returning here.
		if self.source.onlineBta(env, bt) = BTAKind::STATIC then {
			rewrite += newCall;
			return rewrite;
		}
		endif;
	}
	endif;
	
	switch {
		case (opName = 'sum')
		{
			rewrite += mergeSum(newCall, val);
		}
		case (opName = '+' or opName = '*')
		{
			var argBt := newCall.argument->first().onlineBta(env, bt);
			if (argBt = BTAKind::STATIC) then {
				newCall.argument := OrderedSet{val.makeExp()};
			}
			endif;
			rewrite += newCall;
		}
		case (opName = '-')
		{
			newCall.argument := OrderedSet{val.makeExp()};
			newCall.referredOperation.oclAsType(EOperation).name := '+';
			rewrite += newCall;	
		}
		case (opName = 'indexOf')
		{
			rewrite += val.makeExp();
		}
		else 
		{
			rewrite += newCall;
		}
	};

	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// Imperative::IterateExp::merge
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::merge(val : OclAny, env : OclAny, bt : Dict(String, BTAKind)) : OrderedSet(OCLExpression) {
	var rewrite : OrderedSet(OCLExpression) := OrderedSet{};
	switch {
		case (self.name = 'xcollect' or self.name = 'xselect')
		{
			var union := object OperationCallExp {
				referredOperation := object EOperation {
					name := 'union';
				}.oclAsType(EObject);
				source := self.deepclone().oclAsType(OCLExpression);
				argument := OrderedSet{};
				argument += object OperationCallExp {
					referredOperation := object EOperation {
						name := 'as' + 
							if self.eType.oclAsType(CollectionType).kind = ocl::expressions::CollectionKind::Set then 'Set' else 'Bag' endif;
					}.oclAsType(EObject);
					source := val.makeExp();
					
				};
			};
			rewrite += union;	
		}
		else
		{
			rewrite += self;
		}
	};
	return rewrite;
}

///////////////////////////////////////////////////////////////////////////////
//
// mergeHom
//
///////////////////////////////////////////////////////////////////////////////

helper OperationCallExp::mergeHom(val : OclAny) : OrderedSet(OCLExpression) {
	var res : OrderedSet(OCLExpression) := OrderedSet{};
	var mergeExp := object OperationCallExp {
		source := self;
		argument := val.makeExp();
		referredOperation := self.referredOperation.deepclone().oclAsType(EObject);	
	};
	res += mergeExp;
	return res;
}

///////////////////////////////////////////////////////////////////////////////
//
// mergeSum
//
///////////////////////////////////////////////////////////////////////////////

helper mergeSum(sumOp : OperationCallExp, val : OclAny) : OrderedSet(OCLExpression) {
	var res : OrderedSet(OCLExpression) := OrderedSet{};
	var mergeExp := object OperationCallExp {
		source := sumOp;
		argument := val.makeExp();
		referredOperation := object EOperation {
			name := '+';
		}.oclAsType(EObject);
	};
	
	res += mergeExp;
	return res;
}

///////////////////////////////////////////////////////////////////////////////
//
// makeVar
//
///////////////////////////////////////////////////////////////////////////////


helper makeVar(varName : String, val : OclAny) : VariableInitExp {
	return object VariableInitExp {
		referredVariable := object Variable {
			name := varName;
			initExpression := val.makeExp();
		};
		name := referredVariable.name;
	};
}

///////////////////////////////////////////////////////////////////////////////
//
// makeSizeVar
//
///////////////////////////////////////////////////////////////////////////////

helper makeSizeVar(variable : Variable) : VariableInitExp {
	return object VariableInitExp {
		referredVariable := object Variable {
			name := variable.name + 'Size';
			initExpression := object OperationCallExp {
				referredOperation := object EOperation {
					name := 'size';
				}.oclAsType(EObject);
				source := object VariableExp {
					referredVariable := variable;
					name := referredVariable.oclAsType(Variable).name;
					eType := new CollectionType();
				};
			};
		};
		name := referredVariable.name;
	};
}

///////////////////////////////////////////////////////////////////////////////
//
// makeSubsetVar
//
///////////////////////////////////////////////////////////////////////////////

helper makeSubSetVar(variable : Variable) : VariableInitExp {
	
	return object VariableInitExp {
		referredVariable := object Variable {
			name := variable.name + 'Sub';
			initExpression :=  object IfExp {
				condition := object OperationCallExp {
					referredOperation := object EOperation {
						name := '>';
					}.oclAsType(EObject);
					source := object VariableExp {
						referredVariable := object Variable {
							name := variable.name + 'Size';
						};
						name := referredVariable.oclAsType(Variable).name;
					};
					argument := OrderedSet{
						object VariableExp {
							referredVariable := object Variable {
								name := variable.name + 'Last';
							};
							name := referredVariable.oclAsType(Variable).name;
						}
					}
				};
				thenExpression :=	object OperationCallExp {
					source := object VariableExp {
						referredVariable := variable;
						name := referredVariable.oclAsType(Variable).name;
						eType := new CollectionType();
					};
					referredOperation := object EOperation {
						name := 'subOrderedSet';				
					}.oclAsType(EObject);
					argument += object OperationCallExp {
						referredOperation := object EOperation {
							name := '+';
						}.oclAsType(EObject);
						source := object VariableExp {
							referredVariable := object Variable {
								name := variable.name + 'Last';
							};
							name := referredVariable.oclAsType(Variable).name;
						};
						argument += object IntegerLiteralExp {
							integerSymbol := 1;
						};
					};
					argument += object VariableExp {
						referredVariable := object Variable {
							name := variable.name + 'Size';
						};
						name := referredVariable.oclAsType(Variable).name;
					};
				};
				elseExpression := object CollectionLiteralExp {
					kind := ocl::expressions::CollectionKind::OrderedSet;
					eType := object OrderedSetType {
						elementType := variable.eType.oclAsType(EObject);
					};
				};
			}; 
		};
		name := referredVariable.name;
	};
}


///////////////////////////////////////////////////////////////////////////////
//
// makeSourceVariable
//
///////////////////////////////////////////////////////////////////////////////

helper ImperativeIterateExp::makeSourceVariable(varName : String) : VariableInitExp {

	var initExp := self.source.deepclone().oclAsType(OCLExpression);
	if (self.source.oclIsKindOf(ETypedElement)) then {
		var type := self.source.oclAsType(ETypedElement).eType;	
		if (type.oclIsKindOf(SetType)) then {
			initExp := object OperationCallExp {
				referredOperation := object EOperation {
					name := 'asOrderdSet';
				}.oclAsType(EObject);
				source := initExp;
			};
		}
		endif;
	}
	endif;
	
	return object VariableInitExp {
		referredVariable := object Variable {
			name := varName;
			initExpression := initExp;
		};
		name := referredVariable.name;
	};
}

///////////////////////////////////////////////////////////////////////////////
//
// makeLookupExp
//
///////////////////////////////////////////////////////////////////////////////

helper makeLookupExp(cacheName : String) : OCLExpression {
	var lookupExp := object OperationCallExp {
		source := object VariableExp {
			name := cacheName;
			referredVariable := object Variable {
				name := cacheName;
			};
			eType := object DictionaryType {
				name := 'Dict(String, OclAny)';
			};
		};
		
		
		referredOperation := object EOperation {
			name := 'get';
			argument := OrderedSet{
				object OperationCallExp {
					source := object OperationCallExp {
						source := object VariableExp {
							name := 'self';
							referredVariable := object Variable {
								name := 'self';
							};
							eType := object EClass {
								name := 'EObject';
							};
						};
						
						
						referredOperation := object EOperation {
							name := 'oclAsType';
							argument := OrderedSet{
								object TypeExp {
									referredType := object EClass {
										name := 'EObject';
									}.oclAsType(EObject);
								}
							};
							
							eType := object EClass {
								name := 'EObject';
							};
						}.oclAsType(EObject);
					};
					
					referredOperation := object EOperation {
						name := 'path';
					}.oclAsType(EObject);
				}
			};
		}.oclAsType(EObject);
		
		eType := memoizeTables->get(cacheName).eType.getElementType().oclAsType(EClassifier);
	};
	
	return lookupExp;
}




    
